# 📘 O2O智能看板系统 - 业务逻辑与数据字典权威手册

**文档版本**: v3.1  
**创建日期**: 2025-11-12  
**最后更新**: 2025-12-04  
**维护人**: AI Assistant  
**确认状态**: ✅ 用户确认的权威标准

---

## 📋 目录

1. [数据源与结构](#1-数据源与结构)
2. [数据库模型定义](#2-数据库模型定义)
3. [字段完整字典](#3-字段完整字典)
4. [核心业务逻辑](#4-核心业![1762927377719](image/【权威】业务逻辑与数据字典完整手册/1762927377719.png)务逻辑)
5. [计算公式规范](#5-计算公式规范)
6. [指标定义与计算](#6-指标定义与计算)
7. [数据处理流程](#7-数据处理流程)
8. [常见问题FAQ](#8-常见问题faq)
---

## 1. 数据源与结构

### 1.1 数据来源

#### Excel订单数据
- **文件格式**: .xlsx
- **典型字段数**: 32个字段
- **数据特点**: 
    - ⚠️ **多行一订单结构** - 同一订单ID会出现多行,每行对应一个商品SKU
    - ✅ 包含订单级字段(在多行中重复) + 商品级字段(每行不同)
    - 🆕 **平台服务费**是商品级字段，每个商品SKU一条记录，不可用`.first()`替代

#### PostgreSQL数据库
- **数据库名**: o2o_dashboard
- **核心表**:
    - `orders` - 订单表
    - `products` - 商品主数据表
    - `scene_tags` - 场景标签表
    - `analysis_cache` - 分析缓存表

### 1.2 数据结构特点

#### 🔴 关键理解: 多行一订单结构

**示例订单**: 订单ID = 2212367025
```
行1: 订单2212367025 → 商品A(冲锋衣) → 商品实售价:78元, 预计订单收入:69.56元, 利润额:8.78元
行2: 订单2212367025 → 商品B(购物袋) → 商品实售价:0元,  预计订单收入:0元,    利润额:0元
```

**特征**:
- 每行 = 订单中的一个商品
- ⚠️ **重大发现(v2.5)**: "预计订单收入"是**商品级字段**(每行不同值),非订单级!
- **订单级字段**(配送费、佣金等)在多行中**值相同**
- **商品级字段**(商品名称、价格、成本、**预计订单收入**)每行**不同**
- 🆕 **平台服务费**是商品级字段，每个商品SKU一条记录，即便订单ID重复也不能用first聚合

**处理原则**:
```python
# ✅ 正确: 订单级聚合避免重复
order_agg = df.groupby('订单ID').agg({
        '配送费': 'first',           # 订单级字段用first
        '商品实售价': 'sum',         # 商品级字段用sum
        '预计订单收入': 'sum',       # ⭐ 商品级字段用sum (v2.5修正)
        '利润额': 'sum'              # 商品级字段用sum
})

# ❌ 错误: 直接聚合会丢失数据或重复计算
total = df.groupby('订单ID')['预计订单收入'].first().sum()  # 会丢失60%数据!
```

**实际案例验证** (订单2212367025):
- 商品A预计订单收入: ¥69.56
- 商品B预计订单收入: ¥0.00
- 正确聚合(sum): ¥69.56 ✅
- 错误聚合(first): ¥69.56 (恰好正确,但其他订单会丢失数据) ❌

---

## 2. 数据库模型定义

### 2.1 Order表 (订单表)

**表名**: `orders`  
**用途**: 存储所有订单明细数据(一行一商品)

#### 主键和标识
| 字段 | 类型 | 说明 | 索引 |
|------|------|------|------|
| id | Integer | 自增主键 | PK |
| order_id | String(100) | 订单ID | Unique, Index |
| date | DateTime | 下单时间 | Index |
| store_name | String(200) | 门店名称 | - |

#### 商品信息
| 字段 | 类型 | 说明 | 索引 |
|------|------|------|------|
| product_id | Integer | 商品ID(外键) | FK, Index |
| product_name | String(500) | 商品名称 | - |
| barcode | String(100) | 条码 | Index |

#### 分类信息
| 字段 | 类型 | 说明 | 索引 |
|------|------|------|------|
| category_level1 | String(100) | 一级分类 | Index |
| category_level3 | String(100) | 三级分类 | Index |

#### 价格和成本
| 字段 | 类型 | 说明 | 业务含义 |
|------|------|------|---------|
| price | Float | 商品实售价 | **商品级** - 商品折扣价（商家定价，可能含促销）|
| original_price | Float | 商品原价 | **商品级** - 商品原价（未打折前）|
| cost | Float | 商品采购成本 | **商品级** - 商品采购成本 |
| actual_price | Float | 实收价格 | **商品级** - 消费者实付价（含平台补贴后）|

**🔍 字段对比**:
- **商品实售价**: 商家设定的折扣价，反映商家定价策略（不含平台补贴）
- **实收价格**: 消费者实际支付金额（商品实售价 - 平台补贴），反映真实购买力
- **客单价计算**: 应使用`实收价格`，因为它代表消费者真实支出和商家实际收入

#### 销量和金额
| 字段 | 类型 | 说明 | 业务含义 |
|------|------|------|---------|
| quantity | Integer | 销量 | **商品级** - 该商品数量 |
| amount | Float | 销售额 | **商品级** - 该商品小计 |
| profit | Float | 利润 | **商品级** - 该商品利润 |
| profit_margin | Float | 利润率 | **商品级** - 该商品利润率 |

#### 费用 (订单级字段)
| 字段 | 类型 | 说明 | ⚠️ 重复特性 |
|------|------|------|-------------|
| delivery_fee | Float | 物流配送费 | **订单级** - 同订单多行值相同 |
| commission | Float | 平台佣金 | **订单级** - 同订单多行值相同 |
| user_paid_delivery_fee | Float | 用户支付配送费 | **订单级** - 同订单多行值相同 |
| delivery_discount | Float | 配送费减免金额 | **订单级** - 同订单多行值相同 |
| full_reduction | Float | 满减金额 | **订单级** - 同订单多行值相同 |
| product_discount | Float | 商品减免金额 | **订单级** - 同订单多行值相同 |
| merchant_voucher | Float | 商家代金券 | **订单级** - 同订单多行值相同 |
| merchant_share | Float | 商家承担部分券 | **订单级** - 同订单多行值相同 |
| packaging_fee | Float | 打包袋金额 | **订单级** - 同订单多行值相同 |

#### 其他维度
| 字段 | 类型 | 说明 | 索引 |
|------|------|------|------|
| scene | String(50) | 消费场景 | Index |
| time_period | String(50) | 时段 | Index |
| address | Text | 收货地址 | - |
| channel | String(100) | 渠道 | Index |

### 2.2 Product表 (商品主数据)

**表名**: `products`  
**用途**: 存储商品基础信息和当前状态

#### 基础信息
| 字段 | 类型 | 说明 | 索引 |
|------|------|------|------|
| id | Integer | 自增主键 | PK |
| product_name | String(500) | 商品名称 | Index |
| barcode | String(100) | 条码 | Unique, Index |
| store_code | String(100) | 店内码 | - |

#### 库存信息
| 字段 | 类型 | 说明 | 业务含义 |
|------|------|------|---------|
| stock | Integer | 当前库存 | 🔴 **关键字段** - JOIN到订单数据使用 |
| stock_status | String(20) | 库存状态 | 充足/紧张/售罄 |

#### 商品标签
| 字段 | 类型 | 说明 | 业务定义 |
|------|------|------|---------|
| product_role | String(20) | 商品角色 | 流量品/利润品/形象品 |
| lifecycle_stage | String(20) | 生命周期 | 明星/金牛/引流/淘汰 |

---

## 3. 字段完整字典

### 3.1 订单级字段 (Order-Level Fields)

> ⚠️ **重要**: 这些字段在同一订单的所有商品行中**值完全相同**,计算时必须用`.first()`避免重复

| 字段名 | 数据类型 | 业务含义 | 取值范围 | 聚合方式 |
|--------|---------|---------|---------|----------|
| 订单ID | String | 唯一订单标识 | 唯一值 | - |
| 下单时间 / 日期 | DateTime | 订单创建时间 | 有效日期时间 | `.first()` |
| 收货地址 | String | 配送地址 | 文本 | `.first()` |
| 门店名称 | String | 下单门店 | 门店列表 | `.first()` |
| 渠道 | String | 下单平台 | 美团/饿了么/京东等 | `.first()` |
| **预计订单收入** | Float | 订单总收入 | >=0 | `.first()` ⚠️ |
| 配送平台 | String | 配送服务商 | 文本 | `.first()` ⭐ v2.5新增 |
| 用户支付配送费 | Float | 用户付的配送费 | >=0 | `.first()` |
| 配送费减免金额 | Float | 平台减免的配送费 | >=0 | `.first()` |
| 物流配送费 | Float | 实际骑手配送费 | >=0 | `.first()` |
| 平台佣金 | Float | 平台收取的佣金 | >=0 | `.first()` |
| 满减金额 | Float | 满减活动金额 | >=0 | `.first()` |
| **商品减免金额** | Float | 自营销折扣总额（见下方详细说明） | >=0 | `.first()` ⭐ v2.7修正 |
| 商家代金券 | Float | 代金券金额 | >=0 | `.first()` |
| 商家承担部分券 | Float | 商家承担优惠 | >=0 | `.first()` |
| **满赠金额** | Float | 满赠活动金额 | >=0 | `.first()` ⭐ v2.3新增 |
| **商家其他优惠** | Float | 其他商家优惠 | >=0 | `.first()` ⭐ v2.3新增 |
| **新客减免金额** | Float | 新客户优惠 | >=0 | `.first()` ⭐ v2.3新增 |
| 打包袋金额 | Float | 打包费 | >=0 | `.first()` |
| 订单零售额 | Float | 商品原价总和 | >=0 | `.first()` |

#### 🔴 商品减免金额 - 重要业务说明

**业务定义**：
- **含义**：自营销折扣，即商家自主设置的商品折扣金额
- **示例**：某商品原价10元，打折后售价8元，则该商品的减免金额=2元

**数据特性**：
- ⚠️ 虽然折扣是在**商品层面**产生的，但在Excel原始数据中是**订单级字段**
- 即：每行数据中的「商品减免金额」= 该订单中**所有商品**的折扣加总
- 同一订单的多行商品，该字段值**完全相同**

**聚合方式**：
```python
# ✅ 正确：作为订单级字段处理
agg_dict = {
    '商品减免金额': 'first',  # 订单级字段，用first避免重复
}

# ❌ 错误：如果用sum会重复计算
agg_dict = {
    '商品减免金额': 'sum',  # 错误！会导致金额翻倍
}
```

**与其他折扣字段的区别**：
| 字段 | 来源 | 说明 |
|------|------|------|
| 商品减免金额 | 商家自营销 | 商家自主设置的折扣(如打折、特价) |
| 满减金额 | 平台活动 | 满XX减XX活动 |
| 商家代金券 | 商家发券 | 商家发放的优惠券 |

### 3.2 商品级字段 (Item-Level Fields)

> ✅ 这些字段在订单的每个商品行中**值不同**,可以直接`.sum()`

| 字段名 | 数据类型 | 业务含义 | 取值范围 | 聚合方式 |
|--------|---------|---------|---------|----------|
| 商品名称 | String | 商品标识 | 文本 | - |
| 商品条码 / 店内码 | String | 商品编码 | 唯一编码 | - |
| 一级分类名 | String | 大类 | 分类列表 | - |
| 三级分类名 | String | 小类 | 分类列表 | - |
| **商品实售价** | Float | 该商品折扣价（**单价**，商家定价） | >=0 | 按订单聚合`.sum()` / 按商品聚合`.mean()` |
| **实收价格** | Float | 该商品实付价（**单价**，含平台补贴） | >=0 | 按订单聚合`.sum()` ⭐ **客单价计算用此字段** |
| 商品原价 | Float | 该商品原价（**单价**） | >=0 | 按订单聚合`.sum()` / 按商品聚合`.max()` |
| 商品采购成本 / 成本 | Float | 该商品**总成本** | >=0 | `.sum()` ✅ |
| 销量 / 月售 / 商品数量 | Integer | 该商品数量 | >=1 | `.sum()` ✅ |
| **利润额** | Float | 该商品利润 | 可为负 | `.sum()` ✅ ⭐ **商品级** |
| **平台服务费** | Float | 平台按商品收取的技术服务费 | >=0 | `.sum()` ✅ ⭐ **商品级**(一条明细一条服务费) |
| **企客后返** | Float | 该商品企业返现 | >=0 | `.sum()` ⭐ v2.4修正 |
| 库存 | Integer | 当前库存 | >=0 | - |
| 剩余库存 | Integer | 剩余可售 | >=0 | - |

#### 🔴 重要：商品原价和商品实售价是"单价" (v2.9)

**数据特点**：Excel中的`商品原价`和`商品实售价`都是**单价**，不随购买数量变化。

**示例**：
```
红牛: 原价=7元, 实售价=6元, 无论购买2件还是3件，原价和实售价字段都是7元和6元
```

**聚合方式说明**：
- **按订单ID聚合**（计算订单总额）：用 `.sum()` 累加各商品的销售额
- **按商品名称聚合**（计算商品单价）：
  - 商品原价：用 `.max()`（固定定价，取最大值）
  - 商品实售价：用 `.mean()`（可能有促销价差异，取平均值）

#### 🔴 重要：商品采购成本是"总成本"而非"单品成本" (v2.8)

**数据特点**：Excel中的`商品采购成本`字段 = **单品成本 × 销量（月售）**

**示例**：
```
商品A: 销量=2, 商品采购成本=10元 → 单品成本=5元
商品B: 销量=1, 商品采购成本=8元  → 单品成本=8元
```

**正确用法**：
```python
# ✅ 计算单品成本
df['单品成本'] = df['商品采购成本'] / df['月售'].replace(0, 1)

# ✅ 判断价格异常（售价低于成本）
price_abnormal = df['实收价格'] < df['单品成本']

# ❌ 错误：直接比较会误判
wrong = df['实收价格'] < df['商品采购成本']  # 当销量>1时会大量误报!
```

**应用场景**：
- **价格异常预警**：`实收价格 < 单品成本`（卖一单亏一单）
- **毛利计算**：`毛利 = 实收价格 - 单品成本`
- **成本占比**：`成本占比 = 单品成本 / 实收价格`

### 3.3 计算字段 (Calculated Fields)

> 这些字段由原始字段计算得出,不在源数据中

| 字段名 | 计算公式 | 业务含义 | 计算级别 |
|--------|---------|---------|----------|
| **单品成本** | `商品采购成本 / 月售` | 单个商品的采购成本 | 商品级 |
| **商品利润** | `(实收价格 - 单品成本) × 销量` | 单个商品的利润（=利润额） | 商品级 |
| **单品利润率** | `(实收价格 - 单品成本) / 实收价格 × 100` | 单品盈利能力 | 商品级 |
| **定价利润率** | `(商品原价 - 单品成本) / 商品原价 × 100` | 定价策略健康度 | 商品级 |
| **客单价** ⭐ | `SUM(实收价格) / COUNT(DISTINCT 订单ID)` | 平均每订单消费额 | 订单级 |
| 订单总收入 | `实收价格 × 销量`（按商品汇总） | 订单实际收入 | 订单级 |
| 商家活动成本 | `满减+商品减免+代金券+商家券` | 营销成本总额 | 订单级 |
| **配送净成本** | `物流配送费-(用户支付配送费-配送费减免)-企客后返` | **商家真实配送成本** | 订单级 |
| **订单利润** | `利润额 - 平台服务费 - 物流配送费 + 企客后返` | 订单真实净利润 | 订单级 |
| 利润率 | `总利润/销售额×100` | 利润百分比 | 任意级 |
| 库存周转天数 | `当前库存/日均销量` | 库存消耗速度 | 商品级 |
| 滞销天数 | `当前日期-最后销售日期` | 无销量天数 | 商品级 |
| **商品营销费率** ⭐v3.0 | `商品营销成本总额 / 商品销售额总额 × 100` | 该商品的营销活动占比 | 商品级 |
| **真实保本价** ⭐v3.0 | `单品成本 / (1 - 平台费率 - 商品营销费率)` | 覆盖所有成本的最低售价 | 商品级 |
| **高光利润率** ⭐v3.0 | `MAX(商品历史实收利润率)` | 商品曾达到的最高利润率 | 商品级 |

#### 🔴 重要：商品利润 vs 订单利润 (v2.9)

**两个利润概念的区别**：

| 概念 | 公式 | 含义 | 使用场景 |
|------|------|------|---------|
| **商品利润** | `(实收价格 - 单品成本) × 销量` | 该商品的总利润（=利润额） | 商品定价分析、利润率下滑诊断 |
| **订单利润** | `利润额 - 平台服务费 - 物流配送费 + 企客后返` | 订单实际净利润，扣除所有成本 | 订单盈亏分析、真实利润统计 |

**公式详解**：
```python
# 商品利润（商品级）
单品成本 = 商品采购成本 / 销量  # 原始成本是总成本，需除以销量
商品利润 = (实收价格 - 单品成本) × 销量  # 实收价格是单价，需乘以销量
# 等价写法：
商品利润 = 实收价格 × 销量 - 商品采购成本  # 总销售额 - 总成本 = 利润额

# 单品利润率（商品级）
单品利润率 = (实收价格 - 单品成本) / 实收价格 × 100%

# 定价利润率（商品级）
定价利润率 = (商品原价 - 单品成本) / 商品原价 × 100%

# 客单价（订单级） ⭐ 核心指标
客单价 = SUM(实收价格) / COUNT(DISTINCT 订单ID)
# 说明：
# - 必须使用"实收价格"（消费者实付金额），不用"商品实售价"
# - 反映消费者真实购买力和商家实际收入
# - 与财务现金流口径一致
# - 符合电商行业标准（GMV计算）

# 订单利润（订单级）
订单利润 = 利润额 - 平台服务费 - 物流配送费 + 企客后返
```

**原始数据特点**：
| 字段 | 性质 | 说明 | 示例 |
|------|------|------|------|
| 实收价格 | **单价** | 单个商品的售价（需要×销量才能得到销售额） | 实收价格=5元，销量=2，销售额=10元 |
| 商品采购成本（成本） | **总成本** | 已乘以销量（单品成本 × 销量） | 单品成本=3元，销量=2，成本字段=6元 |
| 利润额 | **总利润（毛利）** | 已乘以销量，公式：`(实收价格 × 销量) - 成本` | (5×2)-6=4元 |

**⚠️ 关键理解：利润额的计算口径**
```python
# 原始数据中的"利润额"字段（Excel已计算好）
利润额 = (实收价格 × 销量) - 成本

# 等价于：
利润额 = (实收价格 × 销量) - (单品成本 × 销量)
       = (实收价格 - 单品成本) × 销量

# 注意：
# 1. 实收价格是"单价"，需要×销量
# 2. 成本字段是"总成本"，已经×销量了
# 
# 示例：某订单A商品
# - 实收价格 = 5元/件
# - 销量 = 2件
# - 成本字段 = 6元（单品成本3元×销量2）
# - 利润额 = (5×2) - 6 = 4元
```

**⚠️ 毛利润 vs 净利润**
| 概念 | 计算公式 | 扣除项 | 使用场景 |
|------|---------|--------|---------|
| **毛利润** | `利润额`（原始字段） | 只扣商品成本 | 商品健康分析、定价分析 |
| **净利润** | `利润额 - 营销成本 - 平台费 - 配送费` | 扣除所有成本 | 订单盈亏分析、真实利润统计 |

- **商品维度分析**：使用**毛利率**，关注商品本身盈利能力
- **订单维度分析**：使用**净利率**，反映真实盈亏

**注意事项**：
- `利润额` 是Excel原始字段，已经是总毛利（单件利润 × 销量）
- `平台服务费` 是商品级字段，需要 `.sum()` 汇总
- `物流配送费` 是订单级字段，用 `.first()` 取值
- `企客后返` 是商品级字段，需要 `.sum()` 汇总（做加项，冲减成本）

**应用场景**：
- **商品健康分析**：用毛利润口径，定位具体SKU的定价和成本问题
- **利润率下滑诊断**：用毛利润口径，排除营销活动干扰
- **穿底止血/高配送费**：用净利润口径，反映真实盈亏

---

## 4. 核心业务逻辑

### 4.1 耗材数据剔除规则

**业务规则**: 
- 所有`一级分类名='耗材'`或`美团一级分类='耗材'`的数据**不参与任何统计和计算**
- 典型耗材: 购物袋、打包盒等

**实施位置**: 
- 数据预处理第一步
- 在所有计算之前完成

**代码实现**:
```python
# 剔除耗材
if '一级分类名' in df.columns:
    df = df[~df['一级分类名'].isin(['耗材'])]
```

### 4.2 订单级聚合逻辑

**核心原则**: 
- 先按`订单ID`聚合成**每订单一行**
- 再进行任何维度(分类、渠道、时间等)的统计

**标准聚合字典**:
```python
def calculate_order_metrics(df):
    """订单级聚合 - 避免重复计算"""
    agg_dict = {
        # 订单级字段 - 用first避免重复
        '预计订单收入': 'sum',           # 商品级求和后得订单级
        '用户支付配送费': 'first',
        '配送费减免金额': 'first',
        '物流配送费': 'first',
        '满减金额': 'first',
        '商品减免金额': 'first',
        '商家代金券': 'first',
        '商家承担部分券': 'first',
        '平台佣金': 'first',
        '打包袋金额': 'first',
        
        # 商品级字段 - 用sum累加
        '商品实售价': 'sum',
        '利润额': 'sum',
        '平台服务费': 'sum',
        '月售': 'sum',
        '商品采购成本': 'sum'  # 或'成本'
    }
    
    order_agg = df.groupby('订单ID').agg(agg_dict).reset_index()
    return order_agg
```

### 4.3 分类归属逻辑

**场景**: 一个订单包含多个分类的商品

**规则**: 
- 使用`.first()`取第一个分类作为订单主分类
- 整个订单的收入和利润计入该主分类

**代码**:
```python
# 构建订单→分类映射
order_category_map = df.groupby('订单ID')['一级分类名'].first().to_dict()

# 将分类信息添加到订单聚合数据
order_agg['一级分类名'] = order_agg['订单ID'].map(order_category_map)

# 按分类聚合
category_stats = order_agg.groupby('一级分类名').agg({
    '订单总收入': 'sum',
    '订单实际利润': 'sum'
})
```

**优化方向**: 
- 未来可考虑按商品价值比例分配订单收入到各分类

### 4.4 库存字段处理

**数据来源**:
- `orders`表**没有**库存字段
- `products`表**有**库存字段

**JOIN逻辑**:
```python
# ✅ 正确: JOIN时获取库存
query = db.query(
    Order,
    Product.store_code,
    Product.stock  # 🔴 必须包含
).outerjoin(
    Product, Order.barcode == Product.barcode
)

# 数据解包
for order, store_code, stock in results:
    data.append({
        '库存': stock if stock is not None else 0
    })
```

**注意事项**:
- 如果没有JOIN stock字段,库存将全部为0
- 会导致滞销品、库存周转等指标无法计算

---

## 5. 计算公式规范

### 5.0 渠道过滤逻辑 (v2.8 - 2025-11-24新增)

> ⚠️ **重要**: 在计算所有指标之前,必须先进行渠道过滤,这是确保数据准确性的关键步骤!

#### 5.0.1 收费渠道定义

**代码位置**: `智能门店看板_Dash版.py` 第389-400行

```python
PLATFORM_FEE_CHANNELS = [
    '饿了么',
    '京东到家',
    '美团共橙',
    '美团闪购',
    '抖音',
    '抖音直播',
    '淘鲜达',
    '京东秒送',
    '美团咖啡店',
    '饿了么咖啡店'
]
```

#### 5.0.2 过滤规则

**代码位置**: `智能门店看板_Dash版.py` 第11925-11933行

```python
# 只剔除【收费渠道 且 平台服务费=0】的订单
is_fee_channel = order_agg['渠道'].isin(PLATFORM_FEE_CHANNELS)
is_zero_fee = order_agg.get('平台服务费', 0) <= 0

# 剔除条件: 收费渠道 且 服务费=0
invalid_orders = is_fee_channel & is_zero_fee
filtered = order_agg[~invalid_orders]
```

#### 5.0.3 业务规则

| 渠道类型 | 平台服务费 | 处理方式 | 原因 |
|---------|----------|---------|------|
| **收费渠道** (美团闪购等) | >0 | ✅ 保留 | 正常订单 |
| **收费渠道** | =0 | ❌ 剔除 | 异常订单/测试单 |
| **不收费渠道** (闪购小程序等) | =0 | ✅ 保留 | 正常状态(本身不收费) |
| **不收费渠道** | >0 | ✅ 保留 | 正常订单 |

#### 5.0.4 为什么要区分渠道类型?

**历史问题**:
- 旧版本(v2025-11-21之前): 一刀切剔除所有`平台服务费=0`的订单
- 导致: 闪购小程序、收银机订单等**正常订单**被错误剔除
- 结果: 利润数据失真,少计收入和利润

**修复后**(v2025-11-21):
- 按渠道类型区分过滤逻辑
- 收费渠道: `服务费=0`视为异常 → 剔除
- 不收费渠道: `服务费=0`视为正常 → 保留
- 确保数据完整性和准确性

**示例统计**:
```
📊 [过滤逻辑-按渠道类型] 统计报告:
  总订单数: 10000 单
  收费渠道订单数: 8500 单
  不收费渠道订单数: 1500 单
  收费渠道中服务费=0的订单: 50 单 (异常订单,已剔除)
  不收费渠道中服务费=0的订单: 1500 单 (正常订单,已保留)
  最终保留订单数: 9950 单
```

---

### 5.1 核心利润与配送公式

> 📌 **前提**: 以下所有公式基于渠道过滤后的数据(`filtered`)计算

#### 5.1.1 标准利润公式 (v2.7)

**代码位置**: `智能门店看板_Dash版.py` 第11988-12030行 (`_calculate_profit_formula()`函数)

```
订单实际利润 = 利润额 - 平台服务费 - 物流配送费 + 企客后返
```

**字段要求**:
- `利润额`: 商品级字段,Excel已给出,聚合时`.sum()`
- `平台服务费`: 🆕 商品级字段,一行商品对应一条服务费,聚合时`.sum()`
- `物流配送费`: 订单级字段,聚合时`.first()`
- `企客后返`: 商品级字段,聚合时`.sum()`

**实现要点**:
- 有些旧门店还没有`平台服务费`,公式需自动回退到`平台佣金`
- 物流配送费一律用原始值,与平台类型无关
- 企客后返在原始数据中同样是商品级,缺失时按0处理

```python
platform_fee = order_agg.get('平台服务费', order_agg.get('平台佣金', 0))
order_agg['订单实际利润'] = (
    order_agg['利润额'] -
    platform_fee -
    order_agg['物流配送费'] +
    order_agg.get('企客后返', 0)
)
```

#### 5.1.2 配送净成本 (v2.7)

```
配送净成本 = 物流配送费 - (用户支付配送费 - 配送费减免金额) - 企客后返
```

**业务含义补充**:
- 物流配送费: 商家支付骑手的原始支出
- 用户支付配送费: 客户实付,可视为抵扣支出
- 配送费减免金额: 平台补贴或商家减免,需要冲回
- 企客后返: 针对企业客户的配送补贴,直接冲减配送成本,因此在公式中做减项

**解释**:
- 如果用户支付配送费高于骑手费用,公式会得到负值 → 配送盈利
- 如果企客后返覆盖部分配送费,商家真实承担的配送支出会进一步降低

#### 5.1.3 兼容旧数据的兜底逻辑

1. **缺少平台服务费**: 聚合阶段将`平台服务费`字段填充为0,并在利润公式中自动回退到`平台佣金`
2. **缺少利润额字段**: 启用旧版第二套公式(预计订单收入-成本-佣金-净配送费等),以保证仍可计算订单实际利润
3. **缺少企客后返**: 视为0,保持公式成立
4. **配送平台剔除规则**: 只有在缺少利润额、需要重新推算利润时,才按照`['eleck','美团跑腿-平台扣减','京东平台配送-平台扣减']`将对应骑手费用视为0

> 📌 结论: 现在无论数据是否包含`平台服务费`,利润和配送成本都能保持一致的计算口径;只要新增门店提供了商品级服务费,就会立即进入标准公式。

### 5.2 订单总收入计算

#### 方案A: 使用原始字段

**公式**:
```python
if '预计订单收入' in df.columns:
    订单总收入 = 预计订单收入
```

#### 方案B: 计算得出

**公式**:
```python
订单总收入 = 商品实售价 + 打包袋金额 + 用户支付配送费
```

**代码实现**:
```python
if '预计订单收入' not in order_agg.columns:
    order_agg['订单总收入'] = (
        order_agg['商品实售价'] + 
        order_agg['打包袋金额'] + 
        order_agg['用户支付配送费']
    )
else:
    order_agg['订单总收入'] = order_agg['预计订单收入']
```

### 5.3 商家活动成本（营销成本）

**公式** (v3.1更新 - 2025-01-16):
```
商家活动成本 = 配送费减免金额 + 满减金额 + 商品减免金额 + 商家代金券 + 商家承担部分券 + 满赠金额 + 商家其他优惠 + 新客减免金额
```

**业务含义**: 
- 商家为营销活动承担的总成本（共8个字段）
- **配送费减免金额**: 商家承担的配送费减免（v3.1新增）
- **满减金额**: 满减活动金额
- **商品减免金额**: 商家自营销折扣（商品打折、特价）
- **商家代金券**: 商家发放的优惠券
- **商家承担部分券**: 商家承担的优惠金额
- **满赠金额**: 满赠活动(如满100送20)的赠送金额
- **商家其他优惠**: 其他商家承担的优惠金额
- **新客减免金额**: 新客户优惠（v3.1新增）

**与配送成本的关系**:
- 营销成本和配送成本是两个独立的分析维度
- 配送费减免金额同时出现在两个公式中（允许重叠）
- 营销成本回答"我花了多少钱做促销活动？"
- 配送成本回答"我实际承担了多少配送费？"

**代码**:
```python
marketing_fields = ['配送费减免金额', '满减金额', '商品减免金额', '商家代金券', '商家承担部分券', '满赠金额', '商家其他优惠', '新客减免金额']
order_agg['商家活动成本'] = 0
for field in marketing_fields:
    if field in order_agg.columns:
        order_agg['商家活动成本'] += order_agg[field].fillna(0)
```

**单均营销费用**:
```
单均营销费用 = 商家活动成本 / 订单数
```

### 5.4 GMV（营业额）计算 (v3.2新增 - 2026-01-19)

> ⚠️ **重要**: GMV是营销成本率计算的分母，与商品实收额计算逻辑不同

**公式**:
```
GMV = Σ(商品原价 × 销量) + Σ(打包袋金额) + Σ(用户支付配送费)
```

**数据清洗规则**:
1. **商品原价**: 商品级字段（单价），需要乘以销量才能得出准确的原价销售金额
2. **打包袋金额**: 订单级字段，一个订单只收取一次打包费，需要用`first`聚合避免重复
3. **用户支付配送费**: 订单级字段，清洗逻辑和打包袋金额一致
4. **剔除异常数据**: 计算时需要**剔除商品原价 <= 0 的整行数据**（包括该行的打包袋金额和用户支付配送费）

> ⚠️ **关键说明**: 商品原价=0的订单没有实际商品销售（如纯配送费订单），其打包袋金额和用户支付配送费也不应计入GMV。经验证，惠宜选超市昆山淀山湖镇店2026-01-18有11笔商品原价=0的订单，合计打包袋金额11元、用户支付配送费74元，共85元需要剔除。

**代码实现**:
```python
def calculate_gmv(df: pd.DataFrame) -> Dict[str, float]:
    """计算门店GMV（营业额）"""
    # 1. 剔除商品原价 <= 0 的整行数据（关键！包括该行的打包袋金额和用户支付配送费）
    df = df[df['商品原价'] > 0].copy()
    
    # 2. 计算商品原价销售额 = Σ(商品原价 × 销量)
    df['原价销售额'] = df['商品原价'].fillna(0) * df['月售'].fillna(1)
    original_price_sales = df['原价销售额'].sum()
    
    # 3. 订单级字段聚合（避免重复计算）
    order_level_agg = df.groupby('订单ID').agg({
        '打包袋金额': 'first',
        '用户支付配送费': 'first',
    }).reset_index()
    
    packaging_fee = order_level_agg['打包袋金额'].sum()
    user_delivery_fee = order_level_agg['用户支付配送费'].sum()
    
    # 4. 计算GMV
    gmv = original_price_sales + packaging_fee + user_delivery_fee
    
    return gmv
```

**验证数据**（惠宜选超市昆山淀山湖镇店 2026-01-18）:
- 预期GMV: 8440.66
- 预期营销成本: 1122
- 预期营销成本率: ~13.30%

### 5.5 营销成本率计算 (v3.2更新 - 2026-01-19)

> ⚠️ **重要更新**: 营销成本率的分母从"商品实收额"改为"GMV（营业额）"

**公式**:
```
营销成本率 = 营销成本 / GMV × 100%
```

**营销成本（7字段）**:
```
营销成本 = 满减金额 + 商品减免金额 + 商家代金券 + 商家承担部分券 + 满赠金额 + 商家其他优惠 + 新客减免金额
```

**说明**:
- **配送费减免金额属于配送成本，不属于营销成本**
- 营销成本率反映的是"促销活动投入占营业额的比例"
- 使用GMV作为分母更能反映真实的营销投入效率

**代码实现**:
```python
# 计算营销成本（7字段）
marketing_fields = ['满减金额', '商品减免金额', '商家代金券', '商家承担部分券', '满赠金额', '商家其他优惠', '新客减免金额']
marketing_cost = 0
for field in marketing_fields:
    if field in order_level_agg.columns:
        marketing_cost += order_level_agg[field].fillna(0).sum()

# 计算营销成本率
marketing_cost_rate = (marketing_cost / gmv * 100) if gmv > 0 else 0
```

**与旧版本的区别**:
| 版本 | 分母 | 说明 |
|------|------|------|
| 旧版本 | 商品实收额 | `Σ(实收价格 × 销量)` |
| 新版本(v3.2) | GMV | `Σ(商品原价 × 销量) + 打包袋金额 + 用户支付配送费` |

### 5.6 利润率计算

**公式**:
```
利润率 = (总利润 / 销售额 × 100).round(2)
```

**注意事项**:
- 销售额为0时,利润率填充为0
- 结果保留2位小数
- 单位: 百分比(%)

**代码**:
```python
category_stats['利润率'] = (
    category_stats['总利润'] / category_stats['销售额'] * 100
).round(2).fillna(0)
```

---

## 6. 指标定义与计算

### 6.1 销售指标

| 指标名称 | 计算公式 | 数据级别 | 业务含义 |
|---------|---------|---------|---------|
| 销售额 | 订单总收入之和 | 订单级→任意维度 | 总收入金额 |
| 订单数 | COUNT(DISTINCT 订单ID) | 订单级 | 订单总数 |
| 客单价 | 销售额/订单数 | 订单级 | 平均订单金额 |
| 商品数 | SUM(销量) | 商品级 | 售出商品总数 |
| SKU数 | COUNT(DISTINCT 商品名称) | 商品级 | 不同商品种类数 |

### 6.2 利润指标

| 指标名称 | 计算公式 | 数据级别 | 业务含义 |
|---------|---------|---------|---------|
| 总利润 | 订单实际利润之和 | 订单级→任意维度 | 真实利润总额 |
| 利润率 | 总利润/销售额×100 | 任意级 | 盈利能力 |
| 商品利润 | (实收价格-单品成本)×销量 | 商品级 | 商品层面利润（=利润额） |
| 单品利润率 | (实收价格-单品成本)/实收价格×100 | 商品级 | 单品盈利能力 |
| 定价利润率 | (商品原价-单品成本)/商品原价×100 | 商品级 | 定价策略健康度 |
| 净利 | 总利润-其他成本 | 订单级 | 最终净收益 |

### 6.3 成本指标

| 指标名称 | 计算公式 | 数据级别 | 业务含义 |
|---------|---------|---------|---------|
| 营销成本 | 商家活动成本之和 | 订单级 | 促销活动支出 |
| 配送成本 | 配送成本之和 | 订单级 | 配送净支出 |
| 平台佣金 | 平台佣金之和 | 订单级 | 平台服务费 |
| 营销成本率 | 营销成本/销售额×100 | 订单级 | 营销支出占比 |
| 配送成本率 | 配送成本/销售额×100 | 订单级 | 配送支出占比 |
| 佣金率 | 平台佣金/销售额×100 | 订单级 | 平台抽成比例 |

### 6.4 库存指标

| 指标名称 | 计算公式 | 数据级别 | 业务含义 |
|---------|---------|---------|---------|
| 当前库存 | products.stock | 商品级 | 实时库存数量 |
| 库存周转天数 | 当前库存/日均销量 | 商品级 | 库存消耗速度 |
| 售罄品 | 库存=0且近7天有销量 | 商品级 | 需紧急补货 |
| 滞销品 | 库存>0且N天无销量 | 商品级 | 积压商品 |

**滞销品分级**:
- 🟡 轻度滞销: 7天无销量
- 🟠 中度滞销: 8-15天无销量
- 🔴 重度滞销: 16-30天无销量
- ⚫ 超重度滞销: >30天无销量

### 6.5 渠道指标

| 指标名称 | 计算公式 | 数据级别 | 业务含义 |
|---------|---------|---------|---------|
| 渠道销售额 | 该渠道订单总收入之和 | 订单级→渠道维度 | 渠道收入 |
| 渠道订单数 | 该渠道订单数 | 订单级→渠道维度 | 渠道订单量 |
| 渠道利润 | 该渠道订单实际利润之和 | 订单级→渠道维度 | 渠道盈利 |
| 销售额占比 | 渠道销售额/总销售额×100 | 渠道级 | 渠道贡献度 |

---

## 7. 数据处理流程

### 7.1 标准数据处理流程

```
原始Excel/数据库数据
    ↓
1. 数据加载和验证
    ↓
2. 剔除耗材数据 (一级分类名='耗材')
    ↓
3. 字段标准化 (统一字段名)
    ↓
4. 订单级聚合 (避免重复计算)
    ├─ 订单级字段用.first()
    └─ 商品级字段用.sum()
    ↓
5. 计算衍生字段
    ├─ 商家活动成本
    ├─ 配送成本
    ├─ 订单总收入
    └─ 订单实际利润
    ↓
6. 维度分析聚合
    ├─ 分类维度 (关联分类信息)
    ├─ 渠道维度
    ├─ 时间维度
    └─ 商品维度
    ↓
7. 指标计算
    ├─ 利润率
    ├─ 库存周转
    ├─ 滞销品统计
    └─ 其他业务指标
    ↓
8. 结果展示
```

### 7.2 分类销售分析流程

**问题**: 订单可能包含多个分类的商品,如何归属?

**解决方案**: 
```python
# Step 1: 订单级聚合(已完成,order_agg)
# order_agg中每个订单只有一行

# Step 2: 构建订单→分类映射
order_category_map = df.groupby('订单ID')['一级分类名'].first().to_dict()

# Step 3: 添加分类信息到订单数据
order_agg_with_category = order_agg.copy()
order_agg_with_category['一级分类名'] = order_agg_with_category['订单ID'].map(order_category_map)

# Step 4: 按分类聚合(此时不会重复,每订单只算一次)
category_stats = order_agg_with_category.groupby('一级分类名').agg({
    '订单总收入': 'sum',      # ✅ 销售额
    '订单实际利润': 'sum'     # ✅ 总利润
})

# Step 5: 计算利润率
category_stats['利润率'] = (
    category_stats['总利润'] / category_stats['销售额'] * 100
).round(2)
```

### 7.3 库存数据关联流程

**问题**: 订单表没有库存,需要从商品表JOIN

**解决方案**:
```python
# database/data_source_manager.py

# ✅ 正确的JOIN
query = db.query(
    Order,
    Product.store_code,
    Product.stock  # 🔴 必须包含
).outerjoin(
    Product, 
    Order.barcode == Product.barcode
)

results = query.all()

# ✅ 正确的数据解包
for order, store_code, stock in results:
    data.append({
        '订单ID': order.order_id,
        '商品名称': order.product_name,
        '库存': stock if stock is not None else 0,  # 使用JOIN的值
        '剩余库存': stock if stock is not None else 0
    })
```

**常见错误**:
```python
# ❌ 错误1: 没有JOIN stock字段
query = db.query(Order, Product.store_code).outerjoin(...)

# ❌ 错误2: 硬编码库存为0
for order, store_code in results:
    data.append({'库存': 0})  # 永远是0!
```

---

## 10. 数据导入规则(v2.5新增)

### 10.1 字段映射统一标准

**所有数据导入路径必须遵循相同的字段映射规则**:

#### amount字段映射
```python
# 优先使用"预计订单收入"(商品级字段),备选"订单零售额"
'amount': float(row.get('预计订单收入', row.get('订单零售额', 0)))
```

#### profit字段映射
```python
# 优先使用"利润额",备选"实际利润"
'profit': float(row.get('利润额', row.get('实际利润', 0)))
```

#### delivery_platform字段映射
```python
# 配送平台字段
'delivery_platform': str(row.get('配送平台', ''))
```

### 10.2 导入脚本清单

**所有导入脚本必须字段映射一致**:

| 脚本文件 | 用途 | 状态 |
|---------|------|------|
| `database/migrate.py` | 批量导入数据库 | ✅已修复 |
| `智能导入门店数据.py` | 智能导入系统 | ✅已修复 |
| `智能门店看板_Dash版.py` | 看板上传功能 | ✅已修复 |

### 10.3 数据自动清理规则

#### 耗材剔除
```python
# 所有数据加载路径自动剔除耗材
if '一级分类名' in df.columns:
    df = df[df['一级分类名'] != '耗材'].copy()
```

#### 重复数据清理
- 数据库导入前自动检测重复记录
- 按订单ID+商品名称+日期去重
- 保留最新记录

### 10.4 字段验证规则

**导入数据前必须验证**:
1. 必需字段: 订单ID、商品名称、日期
2. 数值字段: amount、profit、cost等必须>=0
3. 分类字段: 一级分类名不能为空
4. 日期字段: 必须是有效日期格式

---

### Q1: 为什么销售额不能直接sum(商品实售价)?

**A**: 因为订单级字段会重复计算。

**错误示例**:
```python
# ❌ 错误
total_sales = df['商品实售价'].sum()
```

**正确做法**:
```python
# ✅ 正确: 先订单级聚合
order_agg = df.groupby('订单ID').agg({'商品实售价': 'sum'})
total_sales = order_agg['商品实售价'].sum()

# 或使用订单总收入
order_agg = calculate_order_metrics(df)
total_sales = order_agg['订单总收入'].sum()
```

### Q2: 为什么利润需要扣除配送费和佣金?

**A**: 
- `利润额`字段只是商品层面的利润(售价-成本)
- 实际经营还有配送成本、平台佣金等费用
- `订单实际利润` = 商品利润 - 运营成本,才是真实利润

### Q3: 预计订单收入和订单总收入的区别?

**A**:
- `预计订单收入`: Excel原始数据中的字段名
- `订单总收入`: `calculate_order_metrics()`函数计算后的字段名
- 两者含义相同,只是字段名不同
- 代码中统一使用`订单总收入`

### Q4: 为什么库存字段全是0?

**A**: 
- 订单表本身没有库存字段
- 需要从商品表JOIN获取
- 如果JOIN时忘记包含`Product.stock`,就会全是0
- 参见7.3节的正确做法

### Q5: 分类销售分析中,一个订单多个分类如何处理?

**A**:
- 当前方案: 使用`.first()`取第一个分类作为主分类
- 整个订单收入计入该主分类
- 未来可优化: 按商品价值比例分配到各分类

### Q6: 什么时候需要用.first(),什么时候用.sum()?

**A**:
- **订单级字段**(配送费、佣金、满减等) → `.first()`
- **商品级字段**(商品价格、成本、销量、**预计订单收入**、利润额等) → `.sum()`
- ⚠️ **v2.5重大修正**: "预计订单收入"是**商品级字段**,必须用`.sum()`
- 判断依据: 同一订单的多行中,该字段值是否相同?
  - 相同 → 订单级 → `.first()`
  - 不同 → 商品级 → `.sum()`
- **实际验证**: 订单2212367025有2个商品,预计订单收入分别是¥69.56和¥0

### Q7: 耗材数据为什么要剔除?

**A**:
- 耗材(如购物袋)通常价格为0或很低
- 不是实际销售商品,是赠品/包装
- 计入统计会歪曲真实销售情况
- 所以在数据预处理第一步就剔除

### Q8: 如何验证计算逻辑是否正确?

**A**:
1. **整体验证**: 所有分类/渠道的销售额之和 = 所有订单的订单总收入之和
2. **利润验证**: 所有分类/渠道的总利润之和 = 所有订单的订单实际利润之和
3. **利润率验证**: 利润率应在合理范围(-100% ~ 100%)
4. **订单验证**: 随机抽取几个订单,手工计算验证

---

## 9. 看板Tab指标计算逻辑

### 9.1 Tab1: 📊 订单数据概览

**Tab名称**: 订单数据概览  
**回调函数**: `render_tab1_content()`  
**数据级别**: 订单级聚合

#### 核心指标卡片

**看板显示的6个核心指标卡片**:

| 卡片名称 | 显示值来源 | 计算公式 | 代码变量 | 数据来源 |
|---------|----------|---------|---------|---------|
| **📦 订单总数** | `len(order_agg)` | 订单聚合后的行数 | total_orders | order_agg |
| **💰 预计零售额** | `SUM(预计订单收入)` | 按订单ID聚合原始数据的预计订单收入字段 | total_expected_revenue | df原始数据 |
| **💎 总利润** | `order_agg['订单实际利润'].sum()` | 订单实际利润字段求和 | total_profit | order_agg |
| **🎯 平均客单价** | `total_sales / total_orders` | 商品销售额 ÷ 订单数 | avg_order_value | order_agg |
| **📊 总利润率** | `total_profit / total_sales × 100` | 总利润 ÷ 商品销售额 × 100 | profit_rate | 计算得出 |
| **🏪 动销商品数** | `df[df['月售']>0]['商品名称'].nunique()` | 有销量的不重复商品名称数 | total_products | df原始数据 |

**计算流程**:
```python
# Step 1: 订单级聚合 (使用统一函数)
order_agg = calculate_order_metrics(df)

# Step 2: 计算6个卡片的汇总指标
# 📦 卡片1: 订单总数
total_orders = len(order_agg)

# 💰 卡片2: 预计零售额 (特殊处理 - 从原始df取)
if '预计订单收入' in df.columns:
    order_expected_revenue = df.groupby('订单ID')['预计订单收入'].sum()
    total_expected_revenue = order_expected_revenue.sum()  # ⭐ 显示这个值
else:
    total_expected_revenue = 0

# 💎 卡片3: 总利润
total_profit = order_agg['![1762931526636](image/【权威】业务逻辑与数据字典完整手册/1762931526636.png)'].sum()  # ⭐ 已包含配送净成本

# 🎯 卡片4: 平均客单价 (需要中间变量total_sales)
total_sales = order_agg['商品实售价'].sum()  # 商品销售额(不含配送打包)
avg_order_value = total_sales / total_orders if total_orders > 0 else 0

# 📊 卡片5: 总利润率
profit_rate = (total_profit / total_sales * 100) if total_sales > 0 else 0

# 🏪 卡片6: 动销商品数 (从原始df取)
if '商品名称' in df.columns and '月售' in df.columns:
    total_products = df[df['月售'] > 0]['商品名称'].nunique()
else:
    total_products = df['商品名称'].nunique() if '商品名称' in df.columns else 0
```

**关键说明**:

1. **预计零售额卡片** 的特殊性:
   - ❌ 不是用 `order_agg['订单总收入']` 
   - ✅ 而是从**原始df**按订单ID聚合`预计订单收入`字段
   - 原因: 原始数据中`预计订单收入`字段更准确

2. **total_sales 中间变量**:
   - 不直接显示在任何卡片上
   - 仅用于计算**客单价**和**利润率**
   - 代表纯商品销售额(不含配送、打包)

3. **动销商品数卡片**:
   - 从**原始df**统计(不是order_agg)
   - 筛选条件: `月售 > 0`
   - 统计不重复的商品名称数量

#### 渠道表现对比

**渠道列表**: 美团、饿了么、京东等  
**排除渠道**: 收银机订单、闪购小程序

| 渠道指标 | 计算公式 | 说明 |
|---------|---------|------|
| 订单数 | `COUNT(订单ID)` | 该渠道订单数量 |
| 销售额 | `SUM(预计订单收入)` | 使用预计订单收入 |
| 销售额占比 | `渠道销售额 / 总销售额 × 100` | 渠道贡献度 |
| 总利润 | `SUM(订单实际利润)` | 该渠道实际利润 |
| 客单价 | `销售额 / 订单数` | 该渠道平均订单金额 |
| 利润率 | `总利润 / 销售额 × 100` | 该渠道盈利能力 |
| 营销成本率 | `营销成本 / 销售额 × 100` | 营销支出占比 |
| 佣金率 | `平台佣金 / 销售额 × 100` | 平台抽成比例 |
| **配送成本率** | `配送净成本 / 销售额 × 100` | 配送净支出占比 ⭐ |
| **单均营销费用** | `营销成本 / 订单数` | 每单营销成本 |
| **单均配送费支出** | `配送净成本 / 订单数` | 每单配送净成本 ⭐ |
| **单均利润** | `总利润 / 订单数` | 每单平均利润 |

**计算逻辑**:
```python
# 排除特定渠道
excluded_channels = ['收银机订单', '闪购小程序']
order_agg_filtered = order_agg[~order_agg['渠道'].isin(excluded_channels)]

# 按渠道聚合
channel_stats = order_agg_filtered.groupby('渠道').agg({
    '订单ID': 'count',
    '预计订单收入': 'sum',  # 销售额
    '订单实际利润': 'sum',
    '商家活动成本': 'sum',
    '平台佣金': 'sum',
    '配送净成本': 'sum'  # ⭐ 使用配送净成本而非物流配送费
})
```

#### 客单价深度分析

**分析维度**: 按客单价区间分析

| 客单价区间 | 指标 | 计算公式 |
|----------|------|---------|
| 0-20元 | 订单占比 | 该区间订单数/总订单数×100 |
| 20-50元 | 销售额占比 | 该区间销售额/总销售额×100 |
| 50-100元 | 平均利润率 | 该区间总利润/该区间销售额×100 |
| 100元以上 | 亏损订单占比 | 亏损订单数/该区间订单数×100 |

**成本结构分析**:
- 成本率 = 成本/销售额×100
- 平均SKU单价 = 销售额/商品数量
- 单均营销费用 = 营销成本/订单数
- 单均利润 = 总利润/订单数

#### 环比数据计算

**对比周期**: 当前周期 vs 上一等长周期

| 环比指标 | 计算方式 |
|---------|---------|
| 订单数变化 | (当前-上期)/上期×100 |
| 销售额变化 | (当前-上期)/上期×100 |
| 利润变化 | (当前-上期)/上期×100 |
| 客单价变化 | (当前-上期)/上期×100 |
| 利润率变化 | 当前-上期 (百分点) |

**计算函数**: `calculate_period_comparison()`

---

### 9.2 Tab2: 📦 商品分析

**Tab名称**: 商品分析  
**回调函数**: `render_tab2_content()`  
**数据级别**: 商品级聚合

#### 异常数据清洗

**清洗规则**: 同时满足以下三个条件的数据被剔除
- 销量 = 0
- 利润额 = 0  
- 商品采购成本 = 0

```python
abnormal_mask = (
    (df['月售'] == 0) & 
    (df['利润额'] == 0) & 
    (df['商品采购成本'] == 0)
)
df = df[~abnormal_mask]
```

#### 商品维度聚合

**聚合字典**:
```python
product_agg = df.groupby('商品名称').agg({
    '预计订单收入': 'sum',      # 销售额
    '商品采购成本': 'sum',      # 成本
    '利润额': 'sum',            # 实际利润
    '月售': 'sum',              # 总销量
    '库存': 'last',             # 最后库存
    '订单ID': 'nunique',        # 订单数
    '店内码': 'first',
    '一级分类名': 'first',
    '三级分类名': 'first',
    '实收价格': 'sum'          # 如果存在该字段
})
```

#### 商品核心指标

| 指标名称 | 计算公式 | 说明 |
|---------|---------|------|
| 销售额 | `SUM(预计订单收入)` | 商品总销售额 |
| 成本 | `SUM(商品采购成本)` | 商品总成本 |
| 实际利润 | `SUM(利润额)` | 商品层面利润 |
| 总销量 | `SUM(月售)` | 商品售出总数 |
| 库存 | `LAST(库存)` | 最后记录的库存 |
| 订单数 | `COUNT(DISTINCT 订单ID)` | 包含该商品的订单数 |
| 平均售价 | `销售额 / 总销量` | 商品平均单价 |
| 平均成本 | `成本 / 总销量` | 商品平均成本 |
| **利润率** | `实际利润 / 销售额 × 100` | 优先使用实收价格 |

**利润率计算优化**:
```python
# 优先方案: 使用实收价格(排除补贴影响)
if '实收价格' in df.columns:
    利润率 = 实际利润 / 实收价格 × 100
else:
    # 备选方案: 使用预计订单收入
    利润率 = 实际利润 / 销售额 × 100
```

#### 四象限分析

**分类标准**:

| 象限 | 销售额 | 利润率 | 商品角色 |
|------|--------|--------|---------|
| 第一象限 | 高 | 高 | 明星商品 |
| 第二象限 | 低 | 高 | 潜力商品 |
| 第三象限 | 低 | 低 | 淘汰商品 |
| 第四象限 | 高 | 低 | 引流商品 |

**分界线计算**:
- 销售额中位数 = `MEDIAN(销售额)`
- 利润率中位数 = `MEDIAN(利润率)`

#### 商品销售排行

**TOP20商品**: 按销售额降序排列前20

| 排行指标 | 字段 | 说明 |
|---------|------|------|
| 排名 | ROW_NUMBER() | 1-20 |
| 商品名称 | 商品名称 | - |
| 销售额 | 预计订单收入 | - |
| 销量 | 月售 | - |
| 利润 | 实际利润 | - |
| 利润率 | 利润率 | 百分比 |
| 库存 | 库存 | 当前库存 |

---

### 9.3 Tab3: 🔄 分类销售分析

**Tab名称**: 分类销售分析(原Tab3,现整合到Tab2)  
**回调函数**: `create_category_trend_chart_echarts()`  
**数据级别**: 分类级聚合

#### 分类聚合逻辑

**关键问题**: 一个订单可能包含多个分类的商品

**解决方案**: 订单归属主分类
```python
# Step 1: 构建订单→分类映射(取first)
order_category_map = df.groupby('订单ID')['一级分类名'].first().to_dict()

# Step 2: 添加分类信息到订单聚合数据
order_agg['一级分类名'] = order_agg['订单ID'].map(order_category_map)

# Step 3: 按分类聚合(每个订单只算一次)
category_stats = order_agg.groupby('一级分类名').agg({
    '订单总收入': 'sum',      # 销售额
    '订单实际利润': 'sum'     # 总利润
})
```

#### 分类核心指标

| 指标 | 计算公式 | 说明 |
|------|---------|------|
| 分类销售额 | `SUM(订单总收入)` | 该分类订单收入之和 |
| 分类总利润 | `SUM(订单实际利润)` | 该分类利润之和 |
| 分类利润率 | `总利润 / 销售额 × 100` | 该分类盈利能力 |
| **利润额** | `销售额 × 利润率 / 100` | 用于图表显示 |

#### 库存相关指标

**数据要求**: 需要数据包含【库存】和【日期】字段

| 指标 | 计算逻辑 | 分级 |
|------|---------|------|
| 售罄品数 | 库存=0 且 近7天有销量 | 需紧急补货 |
| 轻度滞销 | 库存>0 且 7天无销量 | 🟡 |
| 中度滞销 | 库存>0 且 8-15天无销量 | 🟠 |
| 重度滞销 | 库存>0 且 16-30天无销量 | 🔴 |
| 超重度滞销 | 库存>0 且 >30天无销量 | ⚫ |
| 库存周转天数 | `当前库存 / 日均销量` | 库存消耗速度 |

**滞销品计算**:
```python
# 计算滞销天数
滞销天数 = 当前日期 - 最后销售日期

# 分级统计
轻度滞销 = (滞销天数 == 7) & (库存 > 0)
中度滞销 = (滞销天数 >= 8) & (滞销天数 <= 15) & (库存 > 0)
重度滞销 = (滞销天数 >= 16) & (滞销天数 <= 30) & (库存 > 0)
超重度滞销 = (滞销天数 > 30) & (库存 > 0)
```

#### 图表展示

**图表类型**: ECharts组合图

| 系列 | 类型 | Y轴 | 颜色 | 数据 |
|------|------|-----|------|------|
| 销售额 | 柱状图 | 左Y轴 | 紫色 | category_stats['销售额'] |
| 利润额 | 折线图 | 左Y轴 | 绿色 | category_stats['总利润'] |
| 利润率 | 折线图 | 右Y轴 | 橙色 | category_stats['利润率'] |

**数据展示**: TOP20分类(按销售额降序)

---

### 9.4 Tab5: ⏰ 时段场景分析

**Tab名称**: 时段场景分析  
**回调函数**: `render_tab5_content()`  
**数据级别**: 时段×场景二维聚合

#### 时段定义

| 时段 | 时间范围 | 业务特点 |
|------|---------|---------|
| 早餐时段 | 06:00-09:00 | 早餐需求 |
| 上午时段 | 09:00-11:00 | 上午零食 |
| 午餐时段 | 11:00-14:00 | 午餐需求 |
| 下午时段 | 14:00-17:00 | 下午茶 |
| 晚餐时段 | 17:00-20:00 | 晚餐需求 |
| 夜宵时段 | 20:00-24:00 | 夜宵需求 |
| 深夜时段 | 00:00-06:00 | 深夜需求 |

#### 场景识别

**识别方式**: 基于商品名称和分类的关键词匹配

**场景分类**:
- 基础场景: 早餐、午餐、晚餐、夜宵、下午茶
- 季节场景: 夏季饮品、冬季热饮
- 节假日场景: 节日聚会、周末休闲
- 购买驱动: 即食便捷、健康养生、儿童零食

#### 时段场景矩阵

**聚合维度**: 时段 × 场景

| 矩阵指标 | 计算公式 |
|---------|---------|
| 订单数 | `COUNT(订单ID)` |
| 销售额 | `SUM(订单总收入)` |
| 平均客单价 | `销售额 / 订单数` |
| 总利润 | `SUM(订单实际利润)` |
| 利润率 | `总利润 / 销售额 × 100` |

**可视化**: 热力图(Heatmap)
- X轴: 时段
- Y轴: 场景
- 颜色深度: 销售额/利润率

---

### 9.5 Tab6: 📈 成本优化分析

**Tab名称**: 成本优化分析  
**回调函数**: `render_tab6_content()`

#### 子Tab: 商品成本优化

**分析目标**: 识别高成本、低毛利商品

| 优化指标 | 计算公式 | 优化建议阈值 |
|---------|---------|------------|
| 成本率 | `成本 / 销售额 × 100` | >70% 需优化 |
| 毛利率 | `(销售额-成本) / 销售额 × 100` | <20% 需关注 |
| 采购成本 | `SUM(商品采购成本)` | - |

#### 子Tab: 履约成本优化

**配送成本分析**:

| 指标 | 计算公式 | 说明 |
|------|---------|------|
| 配送费总支出 | `SUM(物流配送费)` | 支付给骑手的费用 |
| 用户支付配送费 | `SUM(用户支付配送费)` | 用户付的配送费 |
| 配送费减免 | `SUM(配送费减免金额)` | 平台补贴 |
| 净配送成本 | `用户支付-减免-物流费` | 实际配送盈亏 |
| 配送成本率 | `配送成本 / 销售额 × 100` | 配送支出占比 |

#### 子Tab: 营销成本优化

**营销活动分析**:

| 营销成本项 | 计算公式 |
|----------|---------|
| 满减金额 | `SUM(满减金额)` |
| 商品减免 | `SUM(商品减免金额)` |
| 商家代金券 | `SUM(商家代金券)` |
| 商家承担券 | `SUM(商家承担部分券)` |
| **营销成本总计** | 以上四项之和 |
| 营销成本率 | `营销成本 / 销售额 × 100` |
| 营销ROI | `(销售额 - 营销成本) / 营销成本` |

---

### 9.6 Tab7: 🤖 AI智能建议

**Tab名称**: AI智能建议  
**回调函数**: `render_tab7_content()`

#### 智能分析维度

1. **商品组合优化**
   - 分析商品关联规则
   - 推荐套餐组合

2. **定价策略建议**
   - 价格弹性分析
   - 竞品价格对比

3. **库存优化建议**
   - 安全库存计算
   - 补货时机预警

4. **营销活动建议**
   - 最优折扣力度
   - 活动时段选择

---

### 9.7 数据处理通用流程

**所有Tab共享的标准流程**:

```
1. 数据加载
   ↓
2. 剔除耗材 (一级分类='耗材')
   ↓
3. 异常数据清洗 (Tab2)
   ↓
4. 订单级聚合 (calculate_order_metrics)
   ├─ 订单级字段: .first()
   └─ 商品级字段: .sum()
   ↓
5. 计算衍生字段
   ├─ 商家活动成本
   ├─ 配送成本
   ├─ 订单总收入
   └─ 订单实际利润
   ↓
6. 维度聚合
   ├─ Tab1: 渠道、客单价区间
   ├─ Tab2: 商品
   ├─ Tab3: 分类
   └─ Tab5: 时段×场景
   ↓
7. 指标计算
   ├─ 利润率
   ├─ 成本率
   ├─ 占比指标
   └─ 环比数据
   ↓
8. 可视化渲染
```

---

## 📚 附录

### 附录A: 关键代码函数

#### calculate_order_metrics()
**位置**: `智能门店看板_Dash版.py` Line 8033-8120  
**用途**: 统一的订单级聚合和指标计算  
**输入**: 原始DataFrame (多行一订单)  
**输出**: order_agg (每订单一行,包含订单总收入、订单实际利润等)  
**核心逻辑**:
```python
def calculate_order_metrics(df):
    # 订单级聚合字典
    agg_dict = {
        '商品实售价': 'sum',
        '利润额': 'sum',
        '用户支付配送费': 'first',
        '物流配送费': 'first',
        '平台佣金': 'first',
        # ... 其他字段
    }
    
    order_agg = df.groupby('订单ID').agg(agg_dict)
    
    # 计算衍生字段
    order_agg['商家活动成本'] = 满减 + 减免 + 代金券 + ...
    order_agg['订单总收入'] = 商品价 + 打包费 + 配送费
    order_agg['订单实际利润'] = 利润额 - 配送费 - 佣金
    
    return order_agg
```

#### create_category_trend_chart_echarts()
**位置**: `智能门店看板_Dash版.py` Line 7280+  
**用途**: 分类销售分析图表  
**关键逻辑**: 
1. 先订单级聚合 (避免重复)
2. 关联分类信息 (订单归属主分类)
3. 按分类汇总 (每订单只算一次)
4. 计算利润率和利润额
5. 渲染ECharts组合图

#### calculate_period_comparison()
**位置**: `智能门店看板_Dash版.py`  
**用途**: 计算环比数据  
**输入**: 完整数据集, 当前周期起止日期  
**输出**: 各指标的环比字典  
**计算逻辑**:
```python
# 计算周期长度
period_days = (end_date - start_date).days + 1

# 上一周期
previous_start = start_date - timedelta(days=period_days)
previous_end = start_date - timedelta(days=1)

# 对比计算
change_rate = (current - previous) / previous × 100
```

### 附录A: 智能调价 V3.0 业务逻辑 ⭐ 新增

> 本节定义智能调价功能的完整业务规则，所有开发必须遵循

#### A.1 核心概念定义

| 概念 | 公式 | 说明 |
|------|------|------|
| **平台费率** | 固定 **8%** | 平台技术服务费，各渠道统一 |
| **商品营销费率** | `商品营销成本总额 / 商品销售额总额` | 按商品单独计算，不同商品不同比例 |
| **真实保本价** | `单品成本 / (1 - 平台费率 - 商品营销费率)` | 覆盖采购+平台+营销成本的最低售价 |
| **高光利润率** | `MAX(该商品历史实收利润率)` | 商品曾经达到的最佳利润水平 |

#### A.2 营销成本字段级别说明 🔴重要

**所有营销成本相关字段都是【订单级】字段**，在同一订单的所有商品行中值完全相同：

| 字段名 | 级别 | 聚合方式 | 说明 |
|--------|------|---------|------|
| 配送费减免金额 | 订单级 | `.first()` | 平台补贴的配送费 |
| 满减金额 | 订单级 | `.first()` | 满XX减XX活动 |
| 商品减免金额 | 订单级 | `.first()` | 订单中所有商品折扣加总（非单品） |
| 商家代金券 | 订单级 | `.first()` | 商家发放的优惠券 |
| 新客减免金额 | 订单级 | `.first()` | 新客户专享优惠 |
| 商家承担部分券 | 订单级 | `.first()` | 商家承担的优惠部分 |
| 满赠金额 | 订单级 | `.first()` | 满赠活动金额 |
| 商家其他优惠 | 订单级 | `.first()` | 其他商家优惠 |

**按商品聚合时的处理**：

由于营销成本是订单级字段，按商品聚合时需要分摊：

```python
# ✅ 正确：按商品占订单销售额比例分摊
商品营销成本 = 订单营销成本 × (商品销售额 / 订单总销售额)

# ❌ 错误：直接把订单营销成本算到每个商品头上
商品营销成本 = 订单营销成本  # 会导致营销成本被放大N倍
```

#### A.3 真实保本价计算

**公式推导**：

商品要不亏损，售价必须覆盖：
1. 采购成本（单品成本）
2. 平台费（售价 × 8%）
3. 营销费（售价 × 营销费率）

```
售价 ≥ 单品成本 + 售价×平台费率 + 售价×营销费率
售价 ≥ 单品成本 + 售价×(平台费率+营销费率)
售价 × (1 - 平台费率 - 营销费率) ≥ 单品成本
售价 ≥ 单品成本 / (1 - 平台费率 - 营销费率)
```

**代码实现**：
```python
def calculate_real_breakeven_price(df):
    """计算真实保本价"""
    # 平台费率固定8%
    PLATFORM_FEE_RATE = 0.08
    
    # 按商品聚合计算营销费率
    product_stats = df.groupby('商品名称').agg({
        '商品销售额': 'sum',
        '分摊营销成本': 'sum',  # 需要先计算分摊营销成本
        '单品成本': 'first'
    })
    
    # 商品营销费率 = 该商品营销成本总额 / 该商品销售额总额
    product_stats['商品营销费率'] = (
        product_stats['分摊营销成本'] / product_stats['商品销售额']
    ).fillna(0).clip(0, 0.5)  # 上限50%，防止异常
    
    # 真实保本价
    divisor = 1 - PLATFORM_FEE_RATE - product_stats['商品营销费率']
    product_stats['真实保本价'] = (
        product_stats['单品成本'] / divisor.clip(lower=0.1)  # 防止除以过小数
    ).round(2)
    
    return product_stats
```

#### A.4 高光利润率计算

**定义**：该商品在历史数据中达到的最高实收利润率

**计算**：
```python
def calculate_peak_profit_rate(df):
    """计算高光利润率"""
    # 每条销售记录的实收利润率
    df['实收利润率'] = (
        (df['实收价格'] - df['单品成本']) / df['实收价格'] * 100
    ).fillna(0)
    
    # 按商品取最大值
    peak_rates = df.groupby('商品名称')['实收利润率'].max().round(2)
    return peak_rates
```

#### A.5 四场景Tab设计

| Tab | 场景 | 筛选条件 | 调价方向 | 默认目标 |
|-----|------|---------|---------|---------|
| Tab1 | **亏损止血** | 实收价格 < 真实保本价 | 涨价 | 真实保本价 |
| Tab2 | **利润修复** | 当前利润率 < 高光利润率 | 涨价 | 高光利润率对应售价 |
| Tab3 | **滞销清仓** | 库存>0 且 滞销≥7天 | 降价 | 用户输入折扣 |
| Tab4 | **促销引流** | 用户自选商品 | 降价 | 用户输入折扣 |

**特殊商品处理**：
- **引流款**（如1元冰露）：显示但**锁定不可调**，标注"引流款-不建议调价"
- **特价款**（低于成本促销）：显示但**锁定不可调**，标注"特价促销中"

#### A.6 字段聚合规则汇总（v2.9确认）

| 字段 | 性质 | 聚合方式 | 备注 |
|------|------|---------|------|
| 商品原价 | **单价** | `.max()` | 固定定价，取最大值 |
| 实收价格/商品实售价 | **单价** | `.mean()` | 可能有促销差异，取平均 |
| 商品采购成本 | **总成本** | `.sum()` ÷ 销量 | 需除以销量得单品成本 |
| 销量/月售 | 数量 | `.sum()` | 直接求和 |
| 利润额 | **总利润** | `.sum()` | 已是总利润 |
| 平台服务费 | 商品级 | `.sum()` | 每条明细一笔 |
| 营销成本字段 | 订单级 | `.first()` | 按比例分摊到商品 |

#### A.7 商品唯一标识规则（v3.1确认）

> ⚠️ **重要规则**：商品聚合时必须使用**店内码**而非商品名称！

**问题案例**：
- 商品名称相同但店内码不同的商品（如不同规格、不同供应商）
- 按商品名称聚合会导致数据混淆：
  - 红牛250ml（店内码1888）原价7元
  - 红牛250ml（店内码4387）原价168元（组合装）
  - 按名称聚合取max后，店内码1888的商品原价变成168元！

**正确做法**：
```python
# ✅ 正确：使用店内码聚合
group_key = '店内码' if '店内码' in df.columns else '商品名称'
product_data = df.groupby(group_key).agg({...})

# ❌ 错误：直接按商品名称聚合
product_data = df.groupby('商品名称').agg({...})  # 会混淆同名不同规格商品
```

**优先级规则**：
1. **店内码** - 首选唯一标识
2. **条码** - 备选标识
3. **商品名称** - 仅在无编码时使用

---

### 附录B: 相关文档

- `订单数据业务逻辑确认.md` - 用户确认的业务定义
- `业务逻辑最终确认.md` - 最终确认的计算公式
- `数据结构统一标准.md` - 字段映射标准
- `数据库库存字段修复说明.md` - 库存JOIN逻辑
- `PostgreSQL环境配置完整指南.md` - 环境配置
- `分类销售额计算逻辑修复说明.md` - 分类聚合逻辑修复

### 附录C: 更新日志

| 日期 | 版本 | 更新内容 | 更新人 |
|------|------|---------|--------|
| 2026-01-19 | v3.2 | **重大新增**: GMV（营业额）计算公式;营销成本率分母从"商品实收额"改为"GMV";新增5.4 GMV计算和5.5营销成本率计算章节;前端运营诊断中心新增"营业额"和"营销成本率"卡片 | AI |
| 2025-12-04 | v3.1 | **重大修正**: 商品聚合必须使用店内码而非商品名称;新增A.7商品唯一标识规则;修复prepare_pricing_data_v2按店内码聚合 | AI |
| 2025-01-28 | v3.0 | **重大新增**: 智能调价V3.0业务逻辑(附录A);新增保本价/营销费率/高光利润率计算字段;明确营销成本字段订单级属性;确认字段聚合规则(原价max/实收mean/成本sum销量) | AI |
| 2025-11-16 | v2.7 | 新增商品级“平台服务费”定义及聚合规则，更新利润/配送净成本新公式并同步字段说明 | AI |
| 2025-01-27 | v2.6 | **重大修正**: "预计订单收入"确认为订单级字段(介v2.5改回订单级);通过诊断脚本验证:同一订单所有商品值相同;修复calculate_order_metrics()使用.first()聚合 | AI |
| 2025-01-27 | v2.5 | **重大修正**: "预计订单收入"确认为商品级字段(从订单级改为商品级);添加"配送平台"字段;更新所有导入脚本字段映射规则 | AI |
| 2025-11-12 | v2.4 | 修正企客后返为商品级字段(从订单级.first()改为商品级.sum()) | AI |
| 2025-11-12 | v2.3 | 新增4个字段:满赠金额、商家其他优惠、新客减免金额、企客后返;更新商家活动成本和订单实际利润公式 | AI |
| 2025-11-12 | v2.2 | 更新Tab1计算逻辑说明,强调配送净成本的使用 | AI |
| 2025-11-12 | v2.1 | 添加所有Tab的完整计算逻辑说明 | AI |
| 2025-11-12 | v2.0 | 创建权威手册,整合所有业务逻辑 | AI |
| 2025-09-25 | v1.5 | 确认利润计算公式和预估订单收入定义 | 用户 |
| 2025-09-24 | v1.0 | 初始业务逻辑确认 | 用户+AI |

### 附录D: 快速查询表

#### 常用指标速查

| 我想计算... | 应该用的公式 | 所在Tab |
|-----------|------------|---------|
| 总利润 | `SUM(订单实际利润)` | Tab1 |
| 利润率 | `总利润/销售额×100` | 所有Tab |
| 客单价 | `销售额/订单数` | Tab1 |
| 商品毛利率 | `(售价-成本)/售价×100` | Tab2 |
| 渠道销售额 | `SUM(预计订单收入) by 渠道` | Tab1 |
| 分类销售额 | `SUM(订单总收入) by 分类` | Tab3 |
| 配送成本 | `用户支付-减免-物流费` | Tab6 |
| 营销成本 | `满减+减免+代金券+...` | Tab6 |
| 库存周转 | `当前库存/日均销量` | Tab3 |
| 滞销天数 | `当前日期-最后销售日期` | Tab3 |

#### 字段名称映射

| Excel字段 | 数据库字段 | 通用名称 | 数据类型 |
|----------|-----------|---------|---------|
| 预计订单收入 | - | 订单总收入 | 订单级 |
| 商品实售价 | price | 商品价格 | 商品级 |
| 商品采购成本/成本 | cost | 成本 | 商品级 |
| 销量/月售 | quantity | 销量 | 商品级 |
| 利润额 | profit | 商品利润 | 商品级 |
| 库存/剩余库存 | stock | 当前库存 | 商品级 |
| 一级分类名 | category_level1 | 大类 | 分类 |

#### 常见错误速查

| 错误症状 | 可能原因 | 解决方案 |
|---------|---------|---------|
| 销售额异常大 | 订单级字段重复计算 | 先订单聚合再统计 |
| 利润为负数很多 | 未扣除配送费和佣金 | 使用订单实际利润 |
| 库存全是0 | 未JOIN库存字段 | 检查database/data_source_manager.py |
| 分类销售额偏大 | 一订单多商品重复算 | 使用订单归属主分类逻辑 |
| 环比数据异常 | 缓存值未更新 | 用卡片显示值覆盖环比current |
| 滞销品统计为"-" | 缺少库存或日期字段 | 检查数据字段完整性 |

---

**文档维护**: 每次业务逻辑变更时必须更新本手册  
**使用原则**: 所有开发和优化必须遵循本手册定义  
**权威性**: 本手册为业务逻辑的唯一权威来源  
**版本**: v2.2 (已更新配送净成本计算逻辑)

**📢 重要声明**: 
本手册基于**最新版本代码**(`智能门店看板_Dash版.py`)编写,所有计算公式、字段定义、处理流程均为当前系统的权威标准。任何新功能开发或优化都必须:

1. **优先查阅本手册** - 了解现有计算逻辑
2. **严格遵循标准** - 不得自行臆测业务规则
3. **保持一致性** - 新功能与现有逻辑保持统一
4. **及时更新文档** - 逻辑变更后立即更新本手册

**使用建议**:
- 🔍 开发前: 查阅相关Tab的计算逻辑
- 📋 开发中: 参考字段字典和公式规范
- ✅ 开发后: 对照快速查询表验证
- 📝 变更后: 更新附录C更新日志
