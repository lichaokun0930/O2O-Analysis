# 问题诊断引擎列兼容性修复说明

## 🔧 修复时间
2025-10-15 17:32

## ❌ 原问题描述

### 错误信息
```
❌ 诊断失败: "Column(s) ['价格帯', '场景'] do not exist"
```

### 错误触发条件
- 用户点击"🔍 解决问题诊断" → "销量下滑诊断" → "开始诊断"
- 用户数据只包含基础字段:`订单ID`, `商品名称`, `商品实售价`, `销量`, `下单时间`等
- 缺少可选字段:`价格带`, `场景`, `商品角色`

### 根本原因

**Pandas .agg() 机制问题：**

```python
# ❌ 错误代码（修复前）
product_info = current_data.groupby('三级分类名').agg({
    '商品实售价': 'mean',
    '价格带': lambda x: x.mode()[0] if '价格带' in current_data.columns else '未知',  # ❌ 失败
    '场景': lambda x: ', '.join(...) if '场景' in current_data.columns else ''  # ❌ 失败
})
```

**问题分析：**
1. Pandas `.agg()` 在执行前会**先验证**所有字典键是否为有效列名
2. Lambda函数内的 `if '价格带' in current_data.columns` 检查在验证之后才执行
3. 因此即使有条件检查,pandas仍会抛出 `KeyError` 或 `ColumnNotFoundError`

## ✅ 修复方案

### 核心思路
**动态构建聚合字典** - 只添加存在的列作为键

### 修复代码示例

```python
# ✅ 正确代码（修复后）
# 1. 先创建基础聚合字典
agg_dict = {
    '商品实售价': 'mean'  # 必需字段
}

# 2. 动态添加可选字段
if '商品角色' in current_data.columns:
    agg_dict['商品角色'] = lambda x: x.mode()[0] if len(x.mode()) > 0 else '未知'

if '价格带' in current_data.columns:
    agg_dict['价格带'] = lambda x: x.mode()[0] if len(x.mode()) > 0 else '未知'

if '时段' in current_data.columns:
    agg_dict['时段'] = lambda x: ', '.join(x.value_counts().head(3).index.tolist())

if '场景' in current_data.columns:
    agg_dict['场景'] = lambda x: ', '.join(x.value_counts().head(2).index.tolist())

# 3. 使用动态构建的字典进行聚合
product_info = current_data.groupby('三级分类名').agg(agg_dict)
```

## 📝 修复位置

### 1. `diagnose_sales_decline()` - 销量下滑诊断
**文件:** `问题诊断引擎.py`  
**行数:** 139-158  
**修改内容:** 

- **修复前:** 硬编码聚合字典,包含`价格带`和`场景`
- **修复后:** 动态构建聚合字典,根据列是否存在添加

**影响:** 现在可以处理缺少`价格带`、`场景`、`商品角色`的数据

---

### 2. `diagnose_customer_price_decline()` - 客单价下滑诊断
**文件:** `问题诊断引擎.py`  
**行数:** 235-250  
**修改内容:**

- **修复前:** 固定包含`商品角色`列
- **修复后:** 动态添加`商品角色`列,动态设置结果列名

**影响:** 支持没有`商品角色`字段的数据

---

### 3. `diagnose_negative_margin_products()` - 负毛利商品诊断
**文件:** `问题诊断引擎.py`  
**行数:** 290-320  
**修改内容:**

- **修复前:** 硬编码聚合`商品角色`、`时段`、`场景`
- **修复后:** 
  - 动态构建聚合字典
  - 动态设置结果列名（根据存在的列）
  
**影响:** 完全兼容缺少可选字段的数据

---

## 🧪 测试验证

### 测试场景1: 完整数据（包含所有可选列）
```python
# 数据包含: 订单ID, 商品名称, 商品实售价, 商品角色, 价格带, 时段, 场景
✅ 期望结果: 正常聚合所有列
```

### 测试场景2: 基础数据（仅必需列）
```python
# 数据只有: 订单ID, 三级分类名, 商品实售价, 日期
✅ 期望结果: 
  - 只聚合商品实售价
  - 不添加商品角色、价格带、时段、场景
  - 不抛出错误
```

### 测试场景3: 部分数据（包含时段,缺少场景）
```python
# 数据包含: 订单ID, 三级分类名, 商品实售价, 时段
✅ 期望结果:
  - 聚合商品实售价和时段
  - 跳过场景和价格带
  - 正常完成诊断
```

## 📊 数据兼容性

### 必需字段（所有诊断都需要）
- ✅ `订单ID`
- ✅ `三级分类名` (或`商品名称`)
- ✅ `商品实售价`
- ✅ `日期` (或`下单时间`)

### 可选字段（有则更详细,无则仍能运行）
- 🔵 `商品角色` - 主力品/凑单品分析
- 🔵 `价格带` - 价格分层分析
- 🔵 `时段` - 时间维度分析
- 🔵 `场景` - 场景营销分析
- 🔵 `单品毛利率` - 毛利分析
- 🔵 `配送费占比` - 配送分析
- 🔵 `收货地址` - 地理分析

## 🎯 修复效果

### Before (修复前)
```
用户点击"开始诊断" 
  ↓
❌ 诊断失败: "Column(s) ['价格帯', '场景'] do not exist"
```

### After (修复后)
```
用户点击"开始诊断"
  ↓
✅ 检测到可用列
  ↓
✅ 动态构建聚合逻辑
  ↓
✅ 成功生成诊断报告（基于实际存在的列）
```

## 💡 设计原则

### 1. **渐进式增强 (Progressive Enhancement)**
- 核心功能基于必需字段
- 可选字段增强分析深度
- 缺少字段不影响基础诊断

### 2. **防御性编程 (Defensive Programming)**
- 在聚合前检查列是否存在
- 动态构建数据结构
- 优雅降级而非崩溃

### 3. **用户友好**
- 即使数据不完整也能运行
- 不强制用户提供所有字段
- 根据实际数据自适应调整

## 🔗 相关文档

- **数据结构标准:** `数据结构统一标准.md`
- **业务逻辑确认:** `订单数据业务逻辑确认.md`
- **场景营销恢复:** `场景营销问题诊断恢复说明.md`

---

**修复日期:** 2025-10-15  
**修复人员:** AI Assistant  
**版本:** v2.0 - 列兼容性修复版本
