# Tab1 订单数据概览 - 卡片计算公式汇总

> 📅 更新日期: 2025-11-16  
> 📊 基于代码: `智能门店看板_Dash版.py` (行号: 9595-9910)  
> 🔧 核心函数: `calculate_order_metrics()` (行号: 9286-9503)

---

## 📋 六大核心卡片

### 1. 📦 订单总数

#### 显示值
```python
total_orders = len(order_agg)
```

#### 计算步骤
1. **数据源**: `order_agg` (订单级聚合数据)
2. **计算方法**: 统计`order_agg`的行数
3. **业务含义**: 去重后的订单数量(每个订单ID只计算一次)

#### 环比计算
```python
comparison_metrics['订单数'] = {
    'current': total_orders,
    'previous': 上期订单数,
    'change_rate': (current - previous) / previous * 100  # 百分比变化率
}
```

#### 数据来源链路
```
原始数据 df 
  → groupby('订单ID') 
  → order_agg 
  → len(order_agg)
```

---

### 2. 💰 预计零售额

#### 显示值
```python
total_expected_revenue = order_agg['订单总收入'].sum()
```

#### 计算步骤
1. **字段来源**: `order_agg['订单总收入']`
2. **订单总收入的计算**:
   ```python
   # 优先使用Excel原始字段
   if '预计订单收入' in order_agg.columns:
       order_agg['订单总收入'] = order_agg['预计订单收入']
   else:
       # 兼容旧数据
       order_agg['订单总收入'] = (
           order_agg['商品实售价'] + 
           order_agg['打包袋金额'] + 
           order_agg['用户支付配送费']
       )
   ```
3. **聚合方式**: 对所有订单求和

#### 业务含义
- Excel中的"预计订单收入"字段
- 包含: 商品售价 + 打包费 + 配送费
- **不扣除任何优惠或成本**

#### 环比计算
```python
comparison_metrics['预计零售额'] = {
    'current': total_expected_revenue,
    'previous': 上期预计零售额,
    'change_rate': (current - previous) / previous * 100
}
```

---

### 3. 💎 总利润

#### 显示值
```python
total_profit = order_agg['订单实际利润'].sum()
```

#### 计算步骤

**核心公式** (全局唯一,定义在`_calculate_profit_formula()`)

```python
订单实际利润 = 利润额 - 平台服务费 - 物流配送费 + 企客后返
```

**详细展开**:

```python
# Step 1: 计算利润额 (如果Excel没有,则从零计算)
if '利润额' in order_agg.columns:
    # 使用Excel原始值 (商品级sum聚合)
    利润额 = order_agg['利润额']  
else:
    # 从零计算
    利润额 = (
        预计订单收入 - 
        商品采购成本 - 
        平台佣金 - 
        实际物流配送费 -  # 剔除eleck等平台
        配送费减免金额 + 
        用户支付配送费 +
        企客后返
    )

# Step 2: 计算订单实际利润 (核心公式)
订单实际利润 = (
    利润额 - 
    平台服务费 -  # 新增字段
    物流配送费 +  # 原始值,不剔除配送平台
    企客后返
)
```

**计算口径** (3种模式):

| 计算口径 | 平台服务费处理 | 过滤条件 |
|---------|--------------|---------|
| `service_fee_positive` (默认) | 仅使用平台服务费 | 平台服务费>0 OR 平台佣金>0 |
| `all_no_fallback` | 仅使用平台服务费 | 无过滤 |
| `all_with_fallback` | 平台服务费≤0时用平台佣金兜底 | 无过滤 |

**关键字段说明**:

```python
# 在calculate_order_metrics中的聚合方式:
'利润额': 'sum',              # 商品级字段,按订单sum
'物流配送费': 'first',         # 订单级字段,取第一个
'平台服务费': 'sum',           # 商品级字段,按订单sum  
'平台佣金': 'first',           # 订单级字段,取第一个
'企客后返': 'sum',             # 商品级字段,按订单sum
```

#### 业务含义
- 门店实际获得的纯利润
- 扣除所有成本: 采购成本、平台费用、配送费用
- 加上补偿项: 企客后返

#### 环比计算
```python
comparison_metrics['总利润'] = {
    'current': total_profit,
    'previous': 上期总利润,
    'change_rate': (current - previous) / previous * 100
}
```

---

### 4. 🛒 平均客单价

#### 显示值
```python
avg_order_value = total_sales / total_orders if total_orders > 0 else 0
```

其中:
```python
total_sales = order_agg['商品实售价'].sum()  # 商品销售额总和
total_orders = len(order_agg)              # 订单总数
```

#### 计算步骤
1. **分子**: 所有订单的商品销售额之和
   - `order_agg['商品实售价']` = 订单内所有商品实售价的sum
2. **分母**: 订单总数
3. **公式**: 商品销售额 ÷ 订单数

#### 业务含义
- 平均每笔订单的商品销售金额
- **仅包含商品售价,不含配送费、打包费等**
- 反映客户平均购买力

#### 字段聚合方式
```python
# 在calculate_order_metrics中:
agg_dict = {
    '商品实售价': 'sum',  # 商品级字段,按订单sum
}
```

#### 环比计算
```python
comparison_metrics['客单价'] = {
    'current': avg_order_value,
    'previous': 上期客单价,
    'change_rate': (current - previous) / previous * 100
}
```

---

### 5. 📈 总利润率

#### 显示值
```python
profit_rate = (total_profit / total_sales * 100) if total_sales > 0 else 0
```

其中:
```python
total_profit = order_agg['订单实际利润'].sum()  # 总利润
total_sales = order_agg['商品实售价'].sum()     # 商品销售额
```

#### 计算步骤
1. **分子**: 总利润 (见卡片3)
2. **分母**: 商品销售额总和
3. **公式**: (总利润 ÷ 商品销售额) × 100%

#### 业务含义
- 门店整体盈利能力
- 每销售100元商品能获得多少利润
- **基准**: 一般超市利润率在8%-15%之间

#### 环比计算
```python
comparison_metrics['总利润率'] = {
    'current': profit_rate,
    'previous': 上期利润率,
    'change_rate': current - previous  # 注意:这里用差值,不是百分比
}
```

#### 特殊说明
⚠️ 利润率的环比显示用**差值**而非百分比:
- 当前15%, 上期12% → 显示: +3.0个百分点
- 而非 +25% (15/12-1)

---

### 6. 🏷️ 动销商品数

#### 显示值
```python
if '商品名称' in df.columns and '月售' in df.columns:
    total_products = df[df['月售'] > 0]['商品名称'].nunique()
else:
    total_products = df['商品名称'].nunique() if '商品名称' in df.columns else 0
```

#### 计算步骤
1. **数据源**: 原始数据 `df` (未聚合)
2. **过滤条件**: `月售 > 0` (有销量的商品)
3. **去重统计**: `商品名称.nunique()`

#### 业务含义
- 有实际销量的SKU数量
- **不是**订单数,也**不是**商品总数
- 反映商品动销率

#### 为什么用原始df而非order_agg?
- `order_agg`是订单级数据,一个订单可能包含多个商品
- `df`是商品级数据,可以准确统计不同商品数量

#### 环比计算
```python
comparison_metrics['动销商品数'] = {
    'current': total_products,
    'previous': 上期动销商品数,
    'change_rate': (current - previous) / previous * 100
}
```

---

## 🔧 核心数据处理流程

### 数据聚合管道

```
┌─────────────────────────────────────────────────────────────┐
│ 原始数据 df (商品级)                                          │
│ - 每行 = 一个商品在一个订单中的记录                            │
│ - 包含: 订单ID, 商品名称, 商品实售价, 成本, 利润额等            │
└─────────────────────────────────────────────────────────────┘
                           ↓
                 groupby('订单ID')
                           ↓
        ┌──────────────────────────────────┐
        │ 聚合规则:                          │
        │ - 订单级字段 → first()             │
        │   (物流配送费, 平台佣金等)          │
        │ - 商品级字段 → sum()               │
        │   (商品实售价, 利润额, 企客后返等)   │
        └──────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ order_agg (订单级)                                            │
│ - 每行 = 一个订单                                             │
│ - 包含: 订单ID, 商品实售价(sum), 预计订单收入(sum)等            │
└─────────────────────────────────────────────────────────────┘
                           ↓
              计算衍生字段 (核心业务逻辑)
                           ↓
        ┌──────────────────────────────────┐
        │ 新增字段:                          │
        │ - 配送净成本                       │
        │ - 商家活动成本                      │
        │ - 订单总收入                        │
        │ - 订单实际利润 ⭐                  │
        └──────────────────────────────────┘
                           ↓
              应用计算口径过滤 (可选)
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 最终 order_agg (用于卡片显示)                                  │
│ - 根据calc_mode过滤 (如service_fee_positive)                 │
│ - 生成6个卡片指标                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 📊 聚合字段映射表

| 字段名称 | 原始层级 | 聚合方式 | 业务含义 |
|---------|---------|---------|---------|
| **商品实售价** | 商品级 | `sum` | 订单内所有商品售价之和 |
| **预计订单收入** | 商品级 | `sum` | 订单总收入(含配送费打包费) |
| **利润额** | 商品级 | `sum` | Excel原始利润额 |
| **企客后返** | 商品级 | `sum` | 企业客户返现(每商品不同) |
| **平台服务费** | 商品级 | `sum` | 新增字段,商品级累加 |
| **月售** | 商品级 | `sum` | 订单内商品销量之和 |
| **物流配送费** | 订单级 | `first` | 整个订单的配送费 |
| **平台佣金** | 订单级 | `first` | 整个订单的平台佣金 |
| **用户支付配送费** | 订单级 | `first` | 用户实际支付的配送费 |
| **配送费减免金额** | 订单级 | `first` | 平台减免的配送费 |
| **满减金额** | 订单级 | `first` | 订单级满减活动 |
| **商品减免金额** | 订单级 | `first` | 商品级优惠总额 |
| **新客减免金额** | 订单级 | `first` | 新客专享优惠 |
| **配送平台** | 订单级 | `first` | 配送服务商 |

---

## 🎯 计算口径详解

### 默认模式: `service_fee_positive`

```python
# 过滤逻辑
filtered = order_agg[
    (order_agg['平台服务费'] > 0) | (order_agg['平台佣金'] > 0)
].copy()
```

**为什么用 OR 条件?**
- 历史原因: 早期数据导入时,Excel的"平台服务费"列被错误映射到`commission`字段
- 兼容性: 同时检查两个字段,确保历史数据和新数据都能正常显示
- 已修复: 新导入的数据会正确映射`platform_service_fee`字段

**适用场景**:
- 仅统计已上报平台服务费的订单
- 更贴近财务口径
- **默认选择**

### 模式2: `all_no_fallback`

```python
# 无过滤,使用所有订单
filtered = order_agg.copy()

# 利润公式仅使用platform_service_fee
订单实际利润 = 利润额 - 平台服务费 - 物流配送费 + 企客后返
```

**适用场景**:
- 全量数据统计
- 平台服务费缺失时不使用平台佣金兜底
- 对比不同计算口径的差异

### 模式3: `all_with_fallback`

```python
# 无过滤,使用所有订单
filtered = order_agg.copy()

# 利润公式: 平台服务费≤0时用平台佣金兜底
if 平台服务费 <= 0:
    使用平台佣金
else:
    使用平台服务费

订单实际利润 = 利润额 - 费用 - 物流配送费 + 企客后返
```

**适用场景**:
- 历史兼容模式
- 确保所有订单都能计算利润
- 平台服务费逐步迁移期间使用

---

## 🔍 特殊字段处理

### 1. 成本字段兼容

```python
# 兼容不同成本字段名
cost_field = '商品采购成本' if '商品采购成本' in df.columns else '成本'

# 统一命名
if cost_field == '成本':
    order_agg['商品采购成本'] = order_agg['成本']
```

### 2. 空值填充

```python
# 配送相关字段必须填充0,避免计算错误
df['物流配送费'] = df['物流配送费'].fillna(0)
df['配送费减免金额'] = df['配送费减免金额'].fillna(0)
df['用户支付配送费'] = df['用户支付配送费'].fillna(0)
```

### 3. 关键字段兜底

```python
# 确保关键字段存在且无空值
if '平台服务费' not in order_agg.columns:
    order_agg['平台服务费'] = 0
order_agg['平台服务费'] = order_agg['平台服务费'].fillna(0)

if '企客后返' not in order_agg.columns:
    order_agg['企客后返'] = 0
else:
    order_agg['企客后返'] = order_agg['企客后返'].fillna(0)
```

---

## ⚡ 性能优化

### 缓存机制

```python
# 检查缓存有效性
cache_valid = (
    cached_agg is not None 
    and cached_comparison is not None 
    and cache_version == trigger  # 版本匹配
)

if cache_valid:
    # 使用缓存,跳过聚合计算
    order_agg = pd.DataFrame(cached_agg)
else:
    # 重新计算
    order_agg = calculate_order_metrics(df)
```

**缓存失效触发**:
- 数据源切换 (Excel ↔ 数据库)
- 日期范围变化
- 数据上传/更新
- 门店切换

---

## 📐 公式验证示例

### 示例订单数据

| 订单ID | 商品实售价 | 预计订单收入 | 利润额 | 平台服务费 | 物流配送费 | 企客后返 |
|--------|----------|------------|-------|-----------|----------|---------|
| A001 | 100 | 105 | 20 | 0.5 | 5 | 0 |
| A002 | 200 | 210 | 40 | 1.0 | 6 | 2 |
| A003 | 150 | 158 | 30 | 0.8 | 5.5 | 1 |

### 卡片计算

```python
# 1. 订单总数
total_orders = 3

# 2. 预计零售额
total_expected_revenue = 105 + 210 + 158 = 473

# 3. 总利润
订单实际利润_A001 = 20 - 0.5 - 5 + 0 = 14.5
订单实际利润_A002 = 40 - 1.0 - 6 + 2 = 35.0
订单实际利润_A003 = 30 - 0.8 - 5.5 + 1 = 24.7
total_profit = 14.5 + 35.0 + 24.7 = 74.2

# 4. 平均客单价
total_sales = 100 + 200 + 150 = 450
avg_order_value = 450 / 3 = 150.00

# 5. 总利润率
profit_rate = (74.2 / 450) * 100 = 16.49%

# 6. 动销商品数 (需要原始商品级数据)
# 假设3个订单共包含5种不同商品,月售都>0
total_products = 5
```

---

## 🚨 常见问题

### Q1: 为什么总利润和预计零售额差距很大?

**A**: 总利润扣除了:
- 商品采购成本 (在利润额中已扣除)
- 平台服务费 (新增扣除项)
- 物流配送费 (再次扣除,确保完整)
- 企客后返 (加回补偿)

### Q2: 客单价为什么不含配送费?

**A**: 客单价 = 商品销售额 / 订单数
- 仅反映商品购买力,不含附加费用
- 便于与行业标准对比
- 配送费收入体现在"预计零售额"中

### Q3: 动销商品数为什么用原始df而非order_agg?

**A**: 
- `order_agg`是订单级,会丢失商品明细
- `df`保留每个商品记录,可准确去重统计
- 避免一个商品在多订单中被重复计数

### Q4: 三种计算口径应该用哪个?

**A**:
- **默认**: `service_fee_positive` (财务口径,仅统计有平台费的订单)
- **全量**: `all_no_fallback` (运营口径,统计所有订单)
- **兼容**: `all_with_fallback` (过渡期使用,确保历史数据可用)

---

## 📝 修改建议

如需修改利润公式,**务必只修改** `_calculate_profit_formula()` 函数:

```python
# 位置: 智能门店看板_Dash版.py, 行号约9505
def _calculate_profit_formula(order_agg, calc_mode):
    """全局唯一利润计算逻辑"""
    
    # 🔧 在这里修改公式
    return (
        order_agg['利润额'] -
        平台服务费 -
        order_agg['物流配送费'] +
        order_agg.get('企客后返', 0)
    )
```

**修改后自动生效的位置**:
- Tab1 订单数据概览 (6个卡片)
- Tab1 环比计算
- Tab1 每日趋势分析
- Tab2 渠道分析
- 所有其他使用订单实际利润的地方

---

## 📌 总结

| 卡片 | 数据源 | 核心公式 | 单位 |
|-----|-------|---------|-----|
| 订单总数 | order_agg | `len(order_agg)` | 笔 |
| 预计零售额 | order_agg | `sum(订单总收入)` | 元 |
| 总利润 | order_agg | `sum(订单实际利润)` | 元 |
| 平均客单价 | order_agg | `sum(商品实售价) / count(订单)` | 元 |
| 总利润率 | order_agg | `总利润 / sum(商品实售价) * 100` | % |
| 动销商品数 | df (原始) | `nunique(商品名称) where 月售>0` | 个 |

**核心公式** (全局唯一):
```python
订单实际利润 = 利润额 - 平台服务费 - 物流配送费 + 企客后返
```
