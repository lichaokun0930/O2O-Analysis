# 单价变化计算逻辑 - 按日期聚合说明

## 🎯 核心问题回答

**Q: 单价是怎么计算的?是随着日期变化计算的吗?**

**A: 是的!** 系统会:
1. **按日期筛选数据** - 筛选出特定日期范围的订单数据
2. **按商品聚合** - 在该日期范围内,对每个商品的所有订单进行聚合
3. **计算平均单价** - 使用该商品在该期间的平均售价

---

## 📊 完整计算流程

### 步骤1: 按日期划分周期

#### 按日分析模式
```python
# 遍历1号-30号,每天与前一天对比
for i in range(29):  # 0-28,共29个对比
    当前日期 = 9月30日 - i天
    对比日期 = 9月30日 - (i+1)天
    
    # 示例:
    # i=0: 9月30日 vs 9月29日
    # i=1: 9月29日 vs 9月28日
    # i=2: 9月28日 vs 9月27日
    # ...
```

**日期范围筛选**:
```python
# 当前日期: 2025-09-30
current_date = (max_date - timedelta(days=0)).date()  # 2025-09-30
current_start = pd.Timestamp(current_date)  # 2025-09-30 00:00:00
current_end = current_start + timedelta(days=1) - timedelta(microseconds=1)  # 2025-09-30 23:59:59

# 对比日期: 2025-09-29
compare_date = (max_date - timedelta(days=1)).date()  # 2025-09-29
compare_start = pd.Timestamp(compare_date)  # 2025-09-29 00:00:00
compare_end = compare_start + timedelta(days=1) - timedelta(microseconds=1)  # 2025-09-29 23:59:59
```

---

### 步骤2: 筛选该日期的所有订单

```python
# 筛选9月30日的所有订单
current_data = df[(df['日期'] >= '2025-09-30 00:00:00') & 
                  (df['日期'] <= '2025-09-30 23:59:59')]

# 筛选9月29日的所有订单
compare_data = df[(df['日期'] >= '2025-09-29 00:00:00') & 
                   (df['日期'] <= '2025-09-29 23:59:59')]
```

**示例数据**:
```
9月30日的订单数据:
订单ID    商品名称    商品实售价    日期
O001     可口可乐    4.0         2025-09-30 10:30:00
O002     可口可乐    4.0         2025-09-30 14:20:00
O003     可口可乐    4.2         2025-09-30 18:45:00
O004     雪碧        3.5         2025-09-30 11:00:00
O005     雪碧        3.5         2025-09-30 15:30:00

9月29日的订单数据:
订单ID    商品名称    商品实售价    日期
O100     可口可乐    3.5         2025-09-29 09:15:00
O101     可口可乐    3.5         2025-09-29 13:40:00
O102     可口可乐    3.6         2025-09-29 16:20:00
O103     雪碧        3.3         2025-09-29 10:50:00
O104     雪碧        3.3         2025-09-29 14:25:00
```

---

### 步骤3: 按商品聚合计算平均单价

```python
# 9月30日可口可乐的平均单价
current_agg = current_data.groupby('商品名称')['商品实售价'].mean()
# 可口可乐: (4.0 + 4.0 + 4.2) / 3 = 4.07元

# 9月29日可口可乐的平均单价
compare_agg = compare_data.groupby('商品名称')['商品实售价'].mean()
# 可口可乐: (3.5 + 3.5 + 3.6) / 3 = 3.53元
```

**详细计算**:
```
商品: 可口可乐

9月30日:
  订单1: ¥4.0
  订单2: ¥4.0
  订单3: ¥4.2
  平均单价 = (4.0 + 4.0 + 4.2) / 3 = ¥4.07 ← 当前单价

9月29日:
  订单1: ¥3.5
  订单2: ¥3.5
  订单3: ¥3.6
  平均单价 = (3.5 + 3.5 + 3.6) / 3 = ¥3.53 ← 之前单价

单价变化 = 4.07 - 3.53 = +¥0.54
单价变化率 = (4.07 - 3.53) / 3.53 × 100 = +15.3%
判定: 💰涨价导致销量降 (>5%)
```

---

## 🔍 为什么要用平均单价?

### 原因1: 处理价格波动
同一天内,同一商品可能有不同的售价:

```
9月30日可口可乐:
  10:30 - ¥4.0 (正常价)
  14:20 - ¥4.0 (正常价)
  18:45 - ¥4.2 (晚间价格略高)

使用平均值: ¥4.07
→ 代表该商品在该天的整体价格水平
```

### 原因2: 处理促销和活动
```
9月15日某商品:
  上午: ¥10.0 (正常价) × 20单
  下午: ¥8.0 (促销价) × 50单
  
平均单价 = (10.0×20 + 8.0×50) / (20+50) = ¥8.57
→ 反映了促销对整体价格的影响
```

### 原因3: 统一对比基准
```
对比两天的价格需要统一口径:
  9月30日平均价 vs 9月29日平均价
  ✅ 可比性强

而不是:
  9月30日最高价 vs 9月29日最低价
  ❌ 对比无意义
```

---

## 📈 实际案例演示

### 案例: 可口可乐的30天价格变化

假设数据:
```
日期        订单数  平均单价  说明
9月1日      100单   ¥3.5     正常价格
9月2日      98单    ¥3.5     价格稳定
9月3日      95单    ¥3.6     略微上涨(+2.9%)
...
9月15日     120单   ¥3.0     促销活动(-14.3%)
9月16日     125单   ¥3.0     促销继续
9月17日     90单    ¥3.8     促销结束,恢复原价(+26.7%)
...
9月29日     100单   ¥3.5     正常价格
9月30日     80单    ¥4.0     涨价(+14.3%)
```

**计算逻辑**:

#### 对比1: 9月30日 vs 9月29日
```python
当前单价 = 9月30日平均单价 = ¥4.0
之前单价 = 9月29日平均单价 = ¥3.5
单价变化率 = (4.0 - 3.5) / 3.5 × 100 = +14.3%
判定: 💰涨价 (>5%)
```

#### 对比2: 9月17日 vs 9月16日
```python
当前单价 = 9月17日平均单价 = ¥3.8
之前单价 = 9月16日平均单价 = ¥3.0
单价变化率 = (3.8 - 3.0) / 3.0 × 100 = +26.7%
判定: 💰涨价 (>5%)
说明: 促销结束,恢复原价
```

#### 对比3: 9月3日 vs 9月2日
```python
当前单价 = 9月3日平均单价 = ¥3.6
之前单价 = 9月2日平均单价 = ¥3.5
单价变化率 = (3.6 - 3.5) / 3.5 × 100 = +2.9%
判定: 📊价格稳定 (<5%)
说明: 变化不足5%,不算涨价
```

---

## 🎨 可视化流程图

```
原始订单数据
    ↓
┌─────────────────────────────────────┐
│ 1. 按日期筛选                        │
│   - 9月30日: 所有该天的订单          │
│   - 9月29日: 所有该天的订单          │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 2. 按商品聚合                        │
│   9月30日:                           │
│   - 可口可乐: 订单1,2,3...           │
│   - 雪碧: 订单4,5,6...               │
│                                      │
│   9月29日:                           │
│   - 可口可乐: 订单100,101,102...     │
│   - 雪碧: 订单103,104,105...         │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 3. 计算平均单价                      │
│   9月30日可口可乐:                   │
│   (4.0 + 4.0 + 4.2) / 3 = ¥4.07    │
│                                      │
│   9月29日可口可乐:                   │
│   (3.5 + 3.5 + 3.6) / 3 = ¥3.53    │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 4. 计算变化                          │
│   单价变化 = 4.07 - 3.53 = +0.54    │
│   变化率 = 0.54 / 3.53 × 100 = +15.3% │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 5. 判定原因                          │
│   15.3% > 5% → 💰涨价               │
└─────────────────────────────────────┘
```

---

## 💡 关键特点

### 1. **逐日对比**
- ✅ 每天与前一天对比
- ✅ 捕捉每日价格变化
- ✅ 识别价格趋势和异常

### 2. **商品级别聚合**
- ✅ 针对每个商品单独计算
- ✅ 不同商品可能有不同的价格策略
- ✅ 精准定位问题商品

### 3. **平均单价**
- ✅ 使用当天所有订单的平均价格
- ✅ 消除单个订单的价格异常
- ✅ 反映整体价格水平

### 4. **滚动对比**
- ✅ 9月30日 vs 9月29日
- ✅ 9月29日 vs 9月28日
- ✅ 9月28日 vs 9月27日
- ✅ ... 一直到9月2日 vs 9月1日

---

## 📊 代码实现（简化版）

```python
# 1. 遍历每一天
for i in range(29):  # 0-28,共29个对比
    # 2. 确定当前日期和对比日期
    当前日期 = 最后一天 - i天
    对比日期 = 最后一天 - (i+1)天
    
    # 3. 筛选该日期的所有订单
    current_data = df[df['日期'].dt.date == 当前日期]
    compare_data = df[df['日期'].dt.date == 对比日期]
    
    # 4. 按商品聚合,计算平均单价
    current_agg = current_data.groupby('商品名称')['商品实售价'].mean()
    compare_agg = compare_data.groupby('商品名称')['商品实售价'].mean()
    
    # 5. 合并数据
    merged = current_agg.to_frame('当前单价').join(
        compare_agg.to_frame('之前单价')
    )
    
    # 6. 计算变化率
    merged['单价变化率'] = (
        (merged['当前单价'] - merged['之前单价']) / merged['之前单价'] * 100
    )
    
    # 7. 判定涨价/降价
    merged['判定'] = merged['单价变化率'].apply(
        lambda x: '💰涨价' if x > 5 
                 else '💸降价' if x < -5 
                 else '📊价格稳定'
    )
```

---

## 🔍 验证示例

假设我们有以下原始数据:

```
订单ID    日期                商品名称    商品实售价
O001     2025-09-30 10:30    可口可乐    4.0
O002     2025-09-30 14:20    可口可乐    4.0
O003     2025-09-30 18:45    可口可乐    4.2
O004     2025-09-29 09:15    可口可乐    3.5
O005     2025-09-29 13:40    可口可乐    3.5
O006     2025-09-29 16:20    可口可乐    3.6
```

**计算过程**:

```
步骤1: 筛选9月30日数据
  → O001, O002, O003

步骤2: 计算9月30日可口可乐平均单价
  → (4.0 + 4.0 + 4.2) / 3 = 4.07

步骤3: 筛选9月29日数据
  → O004, O005, O006

步骤4: 计算9月29日可口可乐平均单价
  → (3.5 + 3.5 + 3.6) / 3 = 3.53

步骤5: 计算变化
  → 单价变化 = 4.07 - 3.53 = 0.54
  → 变化率 = 0.54 / 3.53 × 100 = 15.3%

步骤6: 判定
  → 15.3% > 5% → 💰涨价导致销量降
```

---

## 📝 总结

### 计算方式
✅ **是的,随着日期变化计算**
- 每天与前一天对比
- 使用该天所有订单的平均单价
- 按商品级别单独计算

### 单价定义
```
商品在某一天的单价 = 该商品在该天所有订单的平均售价
```

### 计算公式
```
单价变化率 = (当天平均单价 - 前天平均单价) / 前天平均单价 × 100%
```

### 判定标准
```
变化率 > 5%  → 💰涨价
变化率 < -5% → 💸降价
其他         → 📊价格稳定
```

---

**相关文件**: `问题诊断引擎.py` 第440-835行  
**最后更新**: 2025-10-16
