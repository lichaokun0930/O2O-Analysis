# 📊 智能门店看板 - 统一计算标准

**制定日期**: 2025-10-18  
**适用范围**: 所有 Tab 模块  
**版本**: v1.0

---

## 🎯 核心原则

**所有Tab必须使用相同的计算逻辑，确保数据一致性！**

---

## 📐 标准计算公式

### 1. **订单级聚合（基础）**

**目的**: 避免明细行重复计算，先按订单聚合

```python
order_agg = df.groupby('订单ID').agg({
    '商品实售价': 'sum',           # 商品销售额
    '商品采购成本': 'sum',         # 商品成本
    '利润额': 'sum',              # 原始利润额（未扣除配送和佣金）
    '月售': 'sum',                # 销量
    '用户支付配送费': 'first',    # 用户支付的配送费
    '配送费减免金额': 'first',    # 配送费减免
    '物流配送费': 'first',        # 🔑 商家实际支付给骑手的配送成本
    '满减金额': 'first',          # 满减优惠
    '商品减免金额': 'first',      # 商品优惠
    '商家代金券': 'first',        # 商家代金券
    '商家承担部分券': 'first',    # 🔑 商家承担的平台券
    '平台佣金': 'first',          # 平台佣金
    '打包袋金额': 'first'         # 打包袋收入
}).reset_index()
```

---

### 2. **订单成本计算**

#### A. 商家活动成本
```python
order_agg['商家活动成本'] = (
    order_agg['满减金额'] + 
    order_agg['商品减免金额'] + 
    order_agg['商家代金券'] +
    order_agg['商家承担部分券']  # ✅ 包含商家承担的平台券
)
```

#### B. 订单总收入
```python
order_agg['订单总收入'] = (
    order_agg['商品实售价'] +      # 商品销售额
    order_agg['打包袋金额'] +      # 打包袋收入
    order_agg['用户支付配送费']    # 用户支付的配送费
)
```

#### C. **订单实际利润（核心公式）**
```python
# ✅ 标准公式
order_agg['订单实际利润'] = (
    order_agg['利润额'] -           # 利润额 = 商品销售额 - 商品成本 - 活动成本
    order_agg['物流配送费'] -       # 减去商家实际支付的配送成本
    order_agg['平台佣金']           # 减去平台佣金
)

# 📝 说明：
# - 利润额字段已经包含了商品毛利和活动成本的扣除
# - 物流配送费是商家实际支付给骑手的成本（不是用户支付的配送费）
# - 平台佣金是平台抽成
```

---

### 3. **汇总指标计算**

#### A. 基础指标
```python
total_orders = len(order_agg)                           # 订单总数
total_sales = order_agg['商品实售价'].sum()              # 商品销售额
total_revenue = order_agg['订单总收入'].sum()            # 订单总收入
total_profit = order_agg['订单实际利润'].sum()           # 总利润
```

#### B. 率类指标
```python
# 利润率（基于商品销售额）
profit_rate = (total_profit / total_sales * 100) if total_sales > 0 else 0

# 盈利订单占比
profitable_orders = (order_agg['订单实际利润'] > 0).sum()
profitable_rate = (profitable_orders / total_orders * 100) if total_orders > 0 else 0

# 平均客单价（商品销售额 / 订单数）
avg_order_value = total_sales / total_orders if total_orders > 0 else 0
```

---

### 4. **商品维度聚合**

**注意**: 商品分析时需要先做订单聚合，再做商品聚合

#### 方法 A: 基于订单聚合数据（推荐）
```python
# Step 1: 订单聚合
order_agg = df.groupby('订单ID').agg({
    '商品名称': 'first',  # 保留商品信息
    '商品实售价': 'sum',
    '利润额': 'sum',
    '物流配送费': 'first',
    '平台佣金': 'first',
    # ... 其他字段
}).reset_index()

# Step 2: 计算订单实际利润
order_agg['订单实际利润'] = (
    order_agg['利润额'] - 
    order_agg['物流配送费'] - 
    order_agg['平台佣金']
)

# Step 3: 商品维度聚合
product_agg = order_agg.groupby('商品名称').agg({
    '商品实售价': 'sum',          # 销售额
    '订单实际利润': 'sum',        # ✅ 实际利润
    '订单ID': 'nunique'           # 订单数
}).reset_index()
```

#### 方法 B: 分配利润到商品（如果需要）
```python
# 如果需要将订单级利润分配到每个商品明细行
# 按商品销售额比例分配

# 计算每个商品在订单中的销售额占比
df_with_order = df.merge(
    order_agg[['订单ID', '订单实际利润']],
    on='订单ID',
    how='left'
)

# 计算每个订单的总销售额
order_sales = df.groupby('订单ID')['商品实售价'].sum().reset_index()
order_sales.columns = ['订单ID', '订单总销售额']

df_with_order = df_with_order.merge(order_sales, on='订单ID')

# 分配利润
df_with_order['商品分配利润'] = (
    df_with_order['订单实际利润'] * 
    df_with_order['商品实售价'] / 
    df_with_order['订单总销售额']
)

# 然后按商品聚合
product_agg = df_with_order.groupby('商品名称').agg({
    '商品实售价': 'sum',
    '商品分配利润': 'sum'
}).reset_index()
```

---

### 5. **时间维度聚合**

#### 日维度趋势
```python
# Step 1: 按日期和订单聚合
daily_order_agg = df.groupby([df['日期'].dt.date, '订单ID']).agg({
    '商品实售价': 'sum',
    '利润额': 'sum',
    '物流配送费': 'first',
    '平台佣金': 'first'
}).reset_index()

# Step 2: 计算订单实际利润
daily_order_agg['订单实际利润'] = (
    daily_order_agg['利润额'] - 
    daily_order_agg['物流配送费'] - 
    daily_order_agg['平台佣金']
)

# Step 3: 按日期聚合
daily_sales = daily_order_agg.groupby('日期').agg({
    '商品实售价': 'sum',
    '订单实际利润': 'sum',
    '订单ID': 'nunique'
}).reset_index()
daily_sales.columns = ['日期', '销售额', '总利润', '订单数']
```

---

### 6. **分类维度聚合**

```python
# 基于原始数据聚合（因为分类信息在明细行）
# 但要注意：配送费和佣金不能重复计算

# 方法：仅统计商品销售和商品毛利
category_sales = df.groupby('一级分类名').agg({
    '商品实售价': 'sum',           # 销售额
    '商品采购成本': 'sum',         # 成本
    '利润额': 'sum',               # 毛利（含活动成本）
    '月售': 'sum',                 # 销量
    '订单ID': 'nunique'            # 订单数
}).reset_index()

category_sales['毛利率'] = (
    category_sales['利润额'] / category_sales['商品实售价'] * 100
).fillna(0)
```

---

## ⚠️ 常见错误示例

### ❌ 错误 1: 重复计算配送费和佣金
```python
# ❌ 错误：在明细行聚合时重复计算
product_profit = df.groupby('商品名称').agg({
    '利润额': 'sum',
    '物流配送费': 'sum',  # ❌ 错误！一个订单的配送费被计算多次
    '平台佣金': 'sum'      # ❌ 错误！一个订单的佣金被计算多次
})
```

**✅ 正确**: 先按订单聚合，再按商品聚合

---

### ❌ 错误 2: 使用错误的利润率基数
```python
# ❌ 错误：使用订单总收入作为基数
profit_rate = total_profit / total_revenue * 100  # 错误

# ✅ 正确：使用商品销售额作为基数
profit_rate = total_profit / total_sales * 100  # 正确
```

---

### ❌ 错误 3: 忽略商家承担部分券
```python
# ❌ 错误：遗漏了商家承担的平台券
商家活动成本 = 满减金额 + 商品减免金额 + 商家代金券

# ✅ 正确：包含商家承担部分券
商家活动成本 = 满减金额 + 商品减免金额 + 商家代金券 + 商家承担部分券
```

---

## 📋 各Tab应用检查清单

### Tab 1: 订单数据概览
- ✅ 订单聚合逻辑
- ✅ 订单实际利润计算
- ✅ 汇总指标计算
- ✅ 时间维度趋势
- ✅ 分类维度分析
- ✅ 成本结构分析

### Tab 2: 商品分析
- 🔄 待修复：使用统一的订单聚合逻辑
- 🔄 待修复：商品利润计算方式
- 🔄 待修复：商品排行使用实际利润
- 🔄 待修复：分类分析统一标准

### Tab 3: 价格对比分析
- ⏸️ 待开发

### Tab 4: 问题诊断
- 🔄 待检查：各子模块计算逻辑
- 🔄 待统一：销量下滑诊断
- 🔄 待统一：客单价归因
- 🔄 待统一：负毛利预警

---

## 🔍 验证方法

### 1. 数据一致性验证
```python
# Tab 1 的总利润
tab1_total_profit = order_agg['订单实际利润'].sum()

# Tab 2 商品维度汇总后的总利润
tab2_total_profit = product_agg['实际利润'].sum()

# 应该相等（允许微小浮点误差）
assert abs(tab1_total_profit - tab2_total_profit) < 0.01
```

### 2. 逻辑完整性验证
```python
# 利润公式验证
验证利润 = (
    商品销售额 - 
    商品采购成本 - 
    商家活动成本 - 
    物流配送费 - 
    平台佣金
)

assert abs(验证利润 - 订单实际利润) < 0.01
```

---

## 📝 修改记录

### v1.0 (2025-10-18)
- 建立统一计算标准
- 明确订单聚合逻辑
- 定义核心计算公式
- 提供错误示例和正确做法

---

**维护人**: GitHub Copilot  
**审核状态**: 待用户确认  
**下次更新**: Tab 2 修复完成后
