# 导入脚本修复说明

## 问题分析

在 `database/batch_import.py` 中发现以下问题:

### 1. 日期列识别不完整
- **问题**: 硬编码的日期列列表可能遗漏实际的列名
- **影响**: 可能找不到日期列,导致导入失败或使用错误日期

### 2. 缺少日期时使用当前时间
- **问题**: 如果找不到有效日期,使用 `datetime.now()` 作为默认值
- **影响**: 所有缺少日期的订单都会被记录为"今天",导致数据错误

### 3. 与标准化流程不一致
- **问题**: `真实数据处理器.py` 已经将日期列标准化为"日期",但导入脚本没有优先使用
- **影响**: 可能跳过已标准化的数据

## 修复方案

### 修复1: 增强日期列识别

**修改位置**: `batch_import.py` Line 103-127

**修复前**:
```python
date_col = None
for possible_col in ['日期', '下单时间', '订单时间', '时间', 'date', 'order_date', 'created_at']:
    if possible_col in df.columns:
        date_col = possible_col
        break
```

**修复后**:
```python
date_col = None

# 优先使用标准化后的"日期"列
if '日期' in df.columns:
    date_col = '日期'
    print(f"[日期列] 使用标准化列: {date_col}")
else:
    # 如果没有,尝试其他可能的列名
    possible_date_cols = ['下单时间', '采集时间', 'collect_time', 'timestamp', 
                         '时间', '创建时间', 'date', 'order_date', 'created_at']
    for possible_col in possible_date_cols:
        if possible_col in df.columns:
            date_col = possible_col
            print(f"[日期列] 使用备用列: {date_col}")
            break

if not date_col:
    print(f"[错误] 未找到日期列!")
    print(f"[可用列] {list(df.columns)[:10]}")
    raise ValueError("数据缺少日期列,无法导入")
```

**改进点**:
1. 优先使用标准化后的"日期"列
2. 扩展了备用列名列表
3. 找不到日期列时抛出错误,而不是继续处理

### 修复2: 日期转换安全性

**修改位置**: `batch_import.py` Line 138-155

**修复前**:
```python
order_date = None
if date_col and pd.notna(row.get(date_col)):
    try:
        order_date = pd.to_datetime(row[date_col])
    except Exception as e:
        print(f"[警告] 订单 {order_id} 日期转换失败: {row.get(date_col)} - {e}")

# 如果没有日期,使用当前时间
if order_date is None or pd.isna(order_date):
    print(f"[警告] 订单 {order_id} 缺少有效日期,使用当前时间")
    order_date = datetime.now()  # ❌ 错误! 
```

**修复后**:
```python
order_date = None
if date_col and pd.notna(row.get(date_col)):
    try:
        order_date = pd.to_datetime(row[date_col])
        
        # 检查日期是否有效
        if pd.isna(order_date):
            print(f"[警告] 订单 {order_id} 日期为NaT: {row.get(date_col)}")
            order_date = None
            
    except Exception as e:
        print(f"[警告] 订单 {order_id} 日期转换失败: {row.get(date_col)} - {e}")
        order_date = None

# 如果日期无效,跳过这条记录
if order_date is None or pd.isna(order_date):
    print(f"[跳过] 订单 {order_id} 缺少有效日期")
    errors += 1
    continue  # ✅ 跳过无效记录
```

**改进点**:
1. 增加NaT检查
2. 日期无效时跳过记录,不再使用当前时间
3. 错误计数器增加,便于追踪

## 测试验证

### 测试场景1: 标准化后的数据
```python
# 数据经过 standardize_sales_data() 处理
df = pd.DataFrame({
    '日期': ['2025-01-01', '2025-01-02'],
    '订单ID': ['001', '002']
})

# 预期: 使用"日期"列
# 结果: ✅ 正确识别
```

### 测试场景2: 原始数据
```python
# 数据未经标准化
df = pd.DataFrame({
    '下单时间': ['2025-01-01 10:00:00', '2025-01-02 11:00:00'],
    '订单ID': ['001', '002']
})

# 预期: 使用"下单时间"列
# 结果: ✅ 正确识别
```

### 测试场景3: 缺少日期
```python
df = pd.DataFrame({
    '订单ID': ['001', '002'],
    '商品名称': ['商品A', '商品B']
})

# 预期: 抛出错误
# 结果: ✅ ValueError("数据缺少日期列,无法导入")
```

### 测试场景4: 日期转换失败
```python
df = pd.DataFrame({
    '日期': ['invalid_date', '2025-01-02'],
    '订单ID': ['001', '002']
})

# 预期: 跳过第一条记录,导入第二条
# 结果: ✅ 错误计数+1,第二条记录成功导入
```

## 影响范围

### 受影响的文件
- `database/batch_import.py` ✅ 已修复
- `database/simple_order_import.py` (需要检查)
- `database/quiet_import.py` (需要检查)

### 受影响的功能
- 批量历史数据导入 ✅ 已修复
- 单次数据导入 (需要验证)
- 数据上传功能 (需要验证)

## 后续建议

### 1. 统一日期处理逻辑
建议创建一个公共函数:
```python
def detect_date_column(df: pd.DataFrame) -> Optional[str]:
    """统一的日期列识别逻辑"""
    # 优先使用标准化列名
    if '日期' in df.columns:
        return '日期'
    
    # 备用列名 (与真实数据处理器保持一致)
    possible_cols = [
        '下单时间', '采集时间', 'collect_time', 
        'timestamp', '时间', '创建时间',
        'date', 'order_date', 'created_at'
    ]
    
    for col in possible_cols:
        if col in df.columns:
            return col
    
    return None
```

### 2. 数据质量检查
在导入前增加数据质量检查:
```python
def validate_data_quality(df: pd.DataFrame) -> Dict[str, Any]:
    """数据质量检查"""
    issues = []
    
    # 检查必需列
    required_cols = ['订单ID', '商品名称', '门店名称']
    for col in required_cols:
        if col not in df.columns:
            issues.append(f"缺少必需列: {col}")
    
    # 检查日期列
    date_col = detect_date_column(df)
    if not date_col:
        issues.append("未找到有效的日期列")
    else:
        # 检查日期有效性
        invalid_dates = df[date_col].isna().sum()
        if invalid_dates > 0:
            issues.append(f"存在 {invalid_dates} 条无效日期")
    
    return {
        'valid': len(issues) == 0,
        'issues': issues
    }
```

### 3. 增加导入日志
建议增加详细的导入日志:
```python
# 导入前
logger.info(f"开始导入文件: {filename}")
logger.info(f"数据行数: {len(df)}")
logger.info(f"日期列: {date_col}")
logger.info(f"日期范围: {df[date_col].min()} ~ {df[date_col].max()}")

# 导入后
logger.info(f"导入完成: 成功 {imported}, 更新 {updated}, 错误 {errors}")
```

## 修复确认清单

- [x] 增强日期列识别逻辑
- [x] 修复日期缺失时的处理
- [x] 增加错误处理和日志
- [x] 创建测试脚本
- [ ] 验证其他导入脚本
- [ ] 统一日期处理逻辑
- [ ] 增加数据质量检查
- [ ] 增加详细日志

## 总结

**核心问题**: 日期列识别不可靠,缺少日期时使用当前时间导致数据错误

**修复方案**:
1. 优先使用标准化后的"日期"列
2. 扩展备用列名列表
3. 日期无效时跳过记录,而不是使用假数据
4. 增加详细的错误日志

**验证状态**: ✅ 已修复 `batch_import.py`

**下一步**: 验证其他导入脚本是否存在相同问题
