# 智能调价计算器 V3.0 开发文档

> **文档版本**: V3.0  
> **创建日期**: 2025-12-10  
> **作者**: AI Assistant  
> **适用版本**: 智能门店看板 V3.0+

---

## 📋 目录

1. [功能概述](#功能概述)
2. [核心架构](#核心架构)
3. [商品角色识别](#商品角色识别)
4. [价格弹性计算](#价格弹性计算)
5. [调价策略引擎](#调价策略引擎)
6. [数据流程](#数据流程)
7. [业务规则](#业务规则)
8. [V3.0 核心升级](#v30-核心升级)
9. [已知问题](#已知问题)
10. [优化建议](#优化建议)

---

## 功能概述

### 1.1 核心定位

智能调价计算器是一个**基于数据驱动的定价决策系统**，通过分析商品的销售数据、成本结构、价格弹性等多维度信息，为商家提供科学的调价建议。

### 1.2 主要功能

- **商品角色识别**: 自动识别10种商品角色（引流款、明星款、走量款等）
- **价格弹性分析**: 计算商品的价格敏感度，预测调价后的销量变化
- **智能调价建议**: 基于目标利润率自动计算最优调价方案
- **四大调价场景**: 亏损止血、利润修复、滞销清仓、促销引流
- **弹性系数学习**: 从历史调价效果中学习，持续优化预测准确性
- **批量调价导出**: 支持Excel导出，便于批量执行

### 1.3 应用场景

| 场景 | 说明 | 调价方向 |
|------|------|----------|
| 🩸 亏损止血 | 实收价格 < 真实保本价 | 涨价 |
| 📈 利润修复 | 当前利润率 < 高光利润率 | 涨价 |
| 📦 滞销清仓 | 连续7天+无销量且有库存 | 降价 |
| 🎯 促销引流 | 全部商品，用户自选 | 降价 |

---

## 核心架构

### 2.1 模块结构

```
components/today_must_do/
├── callbacks.py              # 主回调逻辑
│   ├── identify_product_role()          # 商品角色识别
│   ├── prepare_pricing_data_v2()        # 数据准备
│   ├── calculate_pricing_suggestion()   # 调价建议计算
│   └── update_pricing_table_v2()        # 主回调函数
│
├── pricing_engine.py         # 定价引擎
│   ├── get_product_elasticity()         # 弹性系数获取
│   ├── predict_sales_change()           # 销量预测
│   ├── predict_profit_change()          # 利润预测
│   ├── find_optimal_price()             # 最优价格搜索
│   ├── learn_elasticity_from_price_change()  # 弹性学习
│   └── get_stagnant_products()          # 滞销品识别
│
└── diagnosis_analysis.py     # 诊断分析（价格弹性分析）
    └── detect_price_changes_from_orders()  # 价格变动检测
```


### 2.2 技术栈

- **前端框架**: Dash + Dash Bootstrap Components
- **数据处理**: Pandas + NumPy
- **优化算法**: SciPy (SLSQP + 差分进化)
- **存储**: JSON (弹性系数学习数据)

---

## 商品角色识别

### 3.1 角色分类体系（10种）

商品角色识别是调价决策的第一步，基于**销售数据**（而非库存数据）进行分类。

#### 判断优先级（从高到低）

```python
def identify_product_role(
    discount_rate: float,      # 折扣率（0-1）
    profit_rate: float,        # 利润率（%）
    marketing_ratio: float,    # 营销占比（%）
    sales_percentile: float,   # 销量排名百分位（0-1）
    daily_sales: float         # 日均销量
) -> tuple:
```

| 优先级 | 角色 | 判断条件 | 图标 | 调价建议 |
|--------|------|----------|------|----------|
| 1 | 引流款 | 折扣率<30% 或 (营销占比>15% 且 利润率<5%) | 🚀 | 策略性低价，允许调价 |
| 2 | 特价款 | 30%≤折扣率<50% | 🏷️ | 促销商品，允许调价 |
| 3 | 亏损款 | 利润率<0（非引流/特价） | 🔴 | 必须提价止损 |
| 4 | 低频款 | 销量排名后10% | 📦 | 可调价促销 |
| 5 | 明星款 | 高盈利(>20%) + 高动销(前30%) + 低营销(<10%) | 🌟 | 可小幅提价 |
| 6 | 现金牛 | 高盈利 + 高动销 + 高营销 | 💰 | 可试探提价 |
| 7 | 走量款 | 低盈利(5-20%) + 高动销 | ⚡ | 建议提价 |
| 8 | 潜力款 | 高盈利 + 中低动销 | 💎 | 可提价 |
| 9 | 低动销款 | 低盈利(<20%) + 低动销(后30%) | 📉 | 可降价促销 |
| 10 | 正常款 | 其他 | ⚪ | 根据目标调整 |

#### 关键设计理念

1. **策略性低价优先**: 引流款和特价款虽然利润低，但属于策略性定价，不应强制提价
2. **非策略性亏损必须处理**: 非引流/特价的亏损款必须提价止损
3. **动销与利润双维度**: 综合考虑销量排名和利润率，避免单一维度误判

### 3.2 核心指标计算

#### 折扣率
```python
折扣率 = 商品实售价 / 商品原价
```

#### 利润率（定价利润率）
```python
利润率 = (商品实售价 - 单品成本) / 商品实售价 × 100
```
**注意**: 基于商品定价计算，反映定价策略的合理性

#### 营销占比
```python
营销占比 = 营销成本 / 销售额 × 100
```
**注意**: 仅用于参考，不计入保本价

#### 销量排名百分位
```python
销量排名 = rank(商品销量) / 商品总数
```
- 0.9 表示前10%（高动销）
- 0.1 表示后10%（低动销）

---

## 价格弹性计算

### 4.1 弹性系数定义

**价格弹性系数** = 销量变化率 / 价格变化率

- **负数**: 正常情况（涨价→销量降，降价→销量涨）
- **绝对值越大**: 价格敏感度越高
- **绝对值越小**: 刚需品，价格敏感度低

### 4.2 弹性系数获取优先级

```python
def get_product_elasticity(
    product_code: str,
    channel: str,
    category: str,
    price_changes_df: pd.DataFrame = None
) -> Tuple[float, str]:
```

| 优先级 | 来源 | 条件 | 标识 |
|--------|------|------|------|
| 1 | 学习数据 | 该商品在该渠道有≥2次调价样本 | 🎓 |
| 2 | 历史数据 | 该商品在该渠道有≥3次调价记录 | 📊 |
| 3 | 跨渠道历史 | 该商品跨渠道有≥3次调价记录 | 📊 |
| 4 | 品类默认 | 根据一级分类匹配 | ⚠️ |
| 5 | 全局默认 | -1.0 | ⚠️ |

### 4.3 品类默认弹性系数

```python
CATEGORY_ELASTICITY = {
    '饮料': -1.2,       # 较敏感，可替代性强
    '酒水': -0.8,       # 品牌忠诚度高
    '零食': -1.0,       # 中等敏感
    '生鲜': -1.5,       # 高敏感，时效性强
    '水果': -1.4,       # 高敏感
    '蔬菜': -1.3,       # 高敏感
    '日用品': -0.6,     # 刚需，敏感度低
    '粮油调味': -0.5,   # 刚需，敏感度最低
    '乳品烘焙': -0.9,   # 中等偏低
    '个护清洁': -0.7,   # 品牌忠诚度较高
    '母婴': -0.4,       # 刚需，品牌忠诚度极高
    '宠物': -0.5,       # 刚需
    '冷冻冷藏': -1.1,   # 较敏感
    '速食': -0.9,       # 中等
    '耗材': -0.3,       # 必需品，极低敏感
}
```

### 4.4 弹性系数学习机制（V3.0新增）

#### 学习原理

从实际调价效果中反推弹性系数，持续优化预测准确性。

```python
def learn_elasticity_from_price_change(
    product_code: str,
    channel: str,
    old_price: float,
    new_price: float,
    old_daily_sales: float,
    new_daily_sales: float,
    days_after_change: int = 7
) -> Optional[float]:
```

#### 学习公式

```
弹性系数 = (销量变化率) / (价格变化率)

销量变化率 = (新销量 - 旧销量) / 旧销量
价格变化率 = (新价格 - 旧价格) / 旧价格
```

#### 数据有效性检查

1. 价格变化幅度 ≥ 2%（太小不可靠）
2. 调价前必须有销量
3. 弹性合理性：-5 < 弹性 < 1（排除异常值）
4. 使用加权平均更新（新样本权重 = 1/(样本数+1)）

#### 存储格式

```json
{
  "店内码": {
    "渠道": {
      "elasticity": -1.2,
      "samples": 3,
      "last_update": "2025-12-10"
    }
  }
}
```

存储位置: `components/today_must_do/learned_elasticity.json`

---

## 调价策略引擎

### 5.1 调价建议计算

```python
def calculate_pricing_suggestion(
    current_price: float,
    cost: float,
    original_price: float,
    daily_sales: float,
    elasticity: float,
    target_margin: float,
    product_role: str,
    allow_adjust: bool,
    direction: str,
    real_breakeven_price: float = None  # V3.0新增
) -> dict:
```

#### 核心逻辑

1. **计算目标价格**
   ```python
   目标价格 = 成本 / (1 - 目标利润率)
   ```

2. **边界约束**
   - **保本价（floor_price）**: V3.0使用真实保本价（含平台费+营销费）
   - **最高价（ceiling_price）**: 商品原价

3. **方向调整**
   - **涨价模式（up）**: 建议价格 = max(目标价格, 当前价格)，不超过原价
   - **降价模式（down）**: 建议价格 = min(目标价格, 当前价格)，不低于保本价
   - **自动模式（optional）**: 根据目标利润率自动判断涨降

4. **预估变化**
   ```python
   销量变化率 = 价格变化率 × 弹性系数
   利润变化 = (新价格 - 成本) × 新销量 - (当前价格 - 成本) × 当前销量
   ```

### 5.2 销量预测

```python
def predict_sales_change(
    current_price: float,
    new_price: float,
    elasticity: float,
    channel: str = None,
    inventory_days: float = None
) -> Dict[str, float]:
```

#### 预测公式

```
销量变化率 = 价格变化率 × 弹性系数 × 渠道修正 × 库存修正
```

#### 修正系数

**渠道敏感度修正**:
```python
CHANNEL_SENSITIVITY = {
    '美团闪购': 1.1,     # 用户对价格较敏感
    '饿了么': 1.0,       # 中等
    '京东到家': 0.9,     # 用户对价格敏感度略低
    '闪购小程序': 0.8,   # 私域流量，敏感度低
}
```

**库存修正**:
- 库存积压（>30天）: 降价效果增强10%，涨价风险增大20%
- 库存紧张（<7天）: 涨价风险降低20%（供不应求）

### 5.3 利润预测

```python
def predict_profit_change(
    current_price: float,
    new_price: float,
    cost: float,
    current_qty: float,
    elasticity: float,
    channel: str = None
) -> Dict[str, Any]:
```

#### 返回结果

```python
{
    # 当前状态
    'current_price': 当前价格,
    'current_qty': 当前销量,
    'current_profit': 当前利润,
    'current_margin': 当前利润率,
    
    # 新状态预测
    'new_price': 新价格,
    'new_qty': 预测销量,
    'new_profit': 预测利润,
    'new_margin': 预测利润率,
    
    # 变化
    'price_change_rate': 价格变化率%,
    'qty_change_rate': 销量变化率%,
    'profit_change_rate': 利润变化率%,
    'margin_change': 利润率变化(百分点),
}
```


### 5.4 最优价格搜索

```python
def find_optimal_price(
    current_price: float,
    cost: float,
    current_qty: float,
    elasticity: float,
    channel: str = None,
    max_price_increase: float = 0.30,  # 最大涨价幅度30%
    step: float = 0.01  # 步进1%
) -> Dict[str, Any]:
```

#### 搜索原理

遍历不同涨价幅度（0% ~ 30%），找到 **(价格-成本) × 预估销量** 最大的点。

#### 返回结果

```python
{
    'optimal_price': 最优价格,
    'optimal_increase': 最优涨价幅度%,
    'max_profit': 最大预估利润,
    'profit_increase': 利润提升%,
    'warning_threshold': 警告阈值（超过此涨幅利润开始下降）,
    'profit_curve': [
        {'increase': 涨幅%, 'price': 价格, 'profit': 利润, ...},
        ...
    ]
}
```

---

## 数据流程

### 6.1 数据准备流程

```python
def prepare_pricing_data_v2(df: pd.DataFrame, channel: str = None) -> pd.DataFrame:
```

#### 处理步骤

1. **渠道筛选**: 根据用户选择筛选渠道
2. **剔除耗材**: 过滤一级分类为"耗材"的商品
3. **字段映射**: 统一字段名称
   - 销量: `月售` / `销量`
   - 成本: `商品采购成本` / `成本`
   - 价格: `商品实售价` / `实收价格`（优先使用商品实售价）
   - 原价: `商品原价`

4. **计算销售额**
   ```python
   销售额 = 商品实售价 × 销量
   ```
   **注意**: 商品实售价是单价，不是总额

5. **计算营销成本**（订单级分摊）
   ```python
   营销成本字段 = ['满减金额', '新客减免金额', '配送费减免金额', 
                  '商家代金券', '商家承担部分券', '满赠金额', 
                  '商家其他优惠', '商品减免金额']
   
   # 按订单分摊
   订单销售额占比 = 商品销售额 / 订单总销售额
   商品营销成本 = 订单营销总成本 × 订单销售额占比
   ```

6. **动态计算数据周期**
   ```python
   DATA_DAYS = min(max(实际天数, 1), 30)  # 最少1天，最多30天
   ```

7. **聚合到商品级别**
   
   **关键**: 使用**店内码**（而非商品名称）区分商品，避免同名不同规格/价格混淆
   
   ```python
   group_key = '店内码' if '店内码' in df.columns else '商品名称'
   
   agg_dict = {
       '_销售额': 'sum',           # 总销售额
       '_销量': 'sum',             # 总销量
       '_商品原价': 'max',         # 单价，取最大
       '_成本': 'sum',             # 总成本
       '_商品营销成本': 'sum',
       '商品名称': 'first',
   }
   ```

8. **计算核心指标**
   ```python
   # 商品实售价（加权平均）
   实售价格 = 总销售额 / 总销量
   
   # 单品成本
   单品成本 = 总成本 / 销量
   
   # 日均销量
   日均销量 = 总销量 / DATA_DAYS
   
   # 定价利润率
   利润率 = (实售价格 - 单品成本) / 实售价格 × 100
   
   # 折扣率
   折扣率 = 实售价格 / 商品原价
   
   # 营销占比
   营销占比 = 营销成本 / 销售额 × 100
   ```

9. **V3.0核心计算: 真实保本价**
   ```python
   PLATFORM_FEE_RATE = 0.08  # 平台抽成8%
   
   # 商品营销费率（仅供参考，不计入保本价）
   商品营销费率 = (营销占比 / 100).clip(upper=0.50)
   
   # 真实保本价 = 单品成本 / (1 - 平台费率)
   真实保本价 = 单品成本 / (1 - 0.08)  # ≈ 成本 × 1.087
   
   # 是否亏损
   是否亏损 = 实售价格 < 真实保本价
   ```
   
   **说明**: 营销费用是变动成本（可选的促销投入），不应计入保本价。保本价只考虑固定费用：商品成本 + 平台抽成。

10. **V3.0核心计算: 高光利润率**
    ```python
    # 简化处理：当前利润率的1.5倍，最低15%，最高50%
    高光利润率 = (利润率 × 1.5).clip(lower=15, upper=50)
    
    # 是否可修复
    是否可修复 = (利润率 < 高光利润率) & (~是否亏损)
    ```
    
    **TODO**: 后续可以从历史数据中计算真实的高光利润率

11. **计算销量排名百分位**
    ```python
    销量排名 = rank(销量, pct=True, method='average')
    ```

12. **ABC分类**
    ```python
    累计销售额占比:
    - A类: ≤80%
    - B类: 80%-95%
    - C类: >95%
    ```

13. **识别商品角色**
    调用 `identify_product_role()` 函数

### 6.2 主回调流程

```python
@callback(
    [Output("pricing-table-container", "children"),
     Output("pricing-data-store", "data"),
     Output("pricing-batch-status", "children")],
    [Input("pricing-calculate-btn", "n_clicks"),
     Input("pricing-role-store", "data")],
    [State("pricing-direction-store", "data"),
     State("pricing-target-margin-v2", "value"),
     State("db-store-filter", "value"),
     State("pricing-channel-filter", "value")],
)
def update_pricing_table_v2(n_clicks, role_filter, direction, target_margin, store, channel):
```

#### 执行步骤

1. **判断触发来源**
   - `pricing-role-store`: 角色选择触发（只加载商品列表）
   - `pricing-calculate-btn`: 计算按钮触发（执行调价计算）

2. **解析目标利润率**
   - 角色选择触发: `target_margin = None`（只展示列表）
   - 计算按钮触发: 必须有目标利润率，否则提示用户

3. **获取全局数据并筛选**
   ```python
   GLOBAL_DATA = get_real_global_data()
   df = apply_filters_view(GLOBAL_DATA, selected_stores=store_list)
   ```

4. **V3.0调价场景筛选**
   ```python
   if role_filter == 'loss':
       # 🩸 亏损止血：实收价格 < 真实保本价
       products_df = products_df[products_df['是否亏损'] == True]
   
   elif role_filter == 'profit':
       # 📈 利润修复：当前利润率 < 高光利润率（且不亏损）
       products_df = products_df[products_df['是否可修复'] == True]
   
   elif role_filter == 'slow':
       # 📦 滞销清仓：使用滞销品函数
       products_df = get_stagnant_products(df, store_name, 'all')
   
   elif role_filter == 'promo':
       # 🎯 促销引流：全部商品，用户自选
       pass
   ```

5. **如果没有目标利润率，只显示商品列表**
   根据场景展示不同的列：
   - 亏损止血: 真实保本价、亏损额
   - 利润修复: 高光利润率、差距
   - 滞销清仓: 滞销天数、库存
   - 促销引流: 日均销量

6. **动态边界计算**
   ```python
   # 遍历所有商品，计算可达到的最高利润率
   max_achievable_margin = max(
       (原价 - 成本) / 原价 × 100
       for 每个商品
   )
   ```

7. **前置边界校验**
   - 涨价模式: 目标利润率 > 最大可达利润率 → 提示超限
   - 降价模式: 目标利润率 ≤ 0 → 提示低于保本价

8. **遍历商品计算调价方案**
   ```python
   for _, row in products_df.iterrows():
       # 获取弹性系数
       elasticity, elasticity_source = get_product_elasticity(...)
       
       # 计算调价建议
       pricing_result = calculate_pricing_suggestion(...)
       
       # 构建表格数据
       table_data.append({...})
   ```

9. **生成表格和统计**
   - 调价方向统计（涨价/降价/维持）
   - 弹性来源分布（学习/历史/默认）
   - 风险等级分布

---

## 业务规则

### 7.1 价格边界规则

#### 保本价（floor_price）

**V3.0定义**: 真实保本价 = 单品成本 / (1 - 平台费率)

```python
PLATFORM_FEE_RATE = 0.08  # 平台抽成8%
真实保本价 = 单品成本 / 0.92  # ≈ 成本 × 1.087
```

**说明**:
- 营销费用是**变动成本**（可选的促销投入），不计入保本价
- 保本价只考虑**固定费用**: 商品成本 + 平台抽成
- 这样定义的保本价更符合实际业务逻辑

#### 最高价（ceiling_price）

```python
ceiling_price = 商品原价 if 商品原价 > 当前价格 else 当前价格 × 1.5
```

### 7.2 调价方向规则

| 场景 | 方向 | 约束 |
|------|------|------|
| 亏损止血 | 涨价 | 建议价格 ≥ 真实保本价 |
| 利润修复 | 涨价 | 建议价格 ≤ 原价 |
| 滞销清仓 | 降价 | 建议价格 ≥ 保本价 |
| 促销引流 | 降价 | 建议价格 ≥ 保本价 |

### 7.3 滞销品识别规则

```python
def get_stagnant_products(df: pd.DataFrame, store: str = None, level: str = 'all'):
```

#### 滞销定义

**核心条件**: 
1. 库存 > 0（无库存不算滞销）
2. 连续N天无销量

#### 滞销等级

| 等级 | 天数 | 降价幅度 | 标识 |
|------|------|----------|------|
| 轻度 | 7天 | 5-10% | 🟡 |
| 中度 | 8-15天 | 10-15% | 🟠 |
| 重度 | 16-30天 | 15-20% | 🔴 |
| 超重度 | >30天 | 20-30% | ⚫ |

#### 库存获取逻辑（双重判断）

```python
# 步骤1: 获取最后一天有销售的商品库存
last_day_stock_map = last_day_data.groupby('商品名称')['库存'].last()

# 步骤2: 获取每个商品最后一次售卖记录的库存
last_sale_stock_map = df.sort_values('日期').groupby('商品名称')['库存'].last()

# 步骤3: 双重判断 - 优先使用最后一天的库存，否则使用最后售卖时的库存
def get_final_stock(product_name):
    if product_name in last_day_stock_map:
        return last_day_stock_map[product_name]
    elif product_name in last_sale_stock_map:
        return last_sale_stock_map[product_name]
    else:
        return 0
```

**说明**: 这个逻辑与订单数据概览的库存计算保持一致，确保数据准确性。

### 7.4 单品成本计算规则

**关键**: 原始数据中的 `商品采购成本` = 单品成本 × 销量

```python
# 正确计算方式
单品成本 = 商品采购成本 / 销量

# 错误方式（直接使用商品采购成本会导致成本虚高）
单品成本 = 商品采购成本  # ❌ 错误
```

### 7.5 价格字段优先级

```python
# 优先使用商品实售价（商家可调整的定价）
price_col = '商品实售价' if '商品实售价' in df.columns else '实收价格'
```

**原因**: 
- `商品实售价`: 商家设定的售价，反映定价策略
- `实收价格`: 受平台活动影响后的实际收入，不适合作为调价基准

---

## V3.0 核心升级

### 8.1 四大调价场景

替代原来的10种商品角色筛选，更符合实际业务场景。

| 场景 | 识别条件 | 调价方向 | 业务目标 |
|------|----------|----------|----------|
| 🩸 亏损止血 | 实收价格 < 真实保本价 | 涨价 | 止损，恢复到保本线以上 |
| 📈 利润修复 | 当前利润率 < 高光利润率 且 不亏损 | 涨价 | 恢复到历史最佳利润率 |
| 📦 滞销清仓 | 连续7天+无销量 且 库存>0 | 降价 | 清理库存，加快周转 |
| 🎯 促销引流 | 全部商品，用户自选 | 降价 | 吸引流量，提升销量 |

### 8.2 真实保本价计算

**旧版本问题**: 保本价 = 成本 / (1 - 平台费率 - 营销费率)

- 营销费用是变动成本，不应计入保本价
- 导致保本价虚高，限制了调价空间

**V3.0改进**: 真实保本价 = 成本 / (1 - 平台费率)

```python
PLATFORM_FEE_RATE = 0.08  # 平台抽成8%

# 商品营销费率（仅供参考显示，不计入保本价）
商品营销费率 = (营销占比 / 100).clip(upper=0.50)

# 真实保本价
真实保本价 = 单品成本 / (1 - PLATFORM_FEE_RATE)
```

**优势**:
- 保本价更合理，符合实际业务逻辑
- 扩大了调价空间，特别是降价场景
- 营销费用作为参考指标单独展示

### 8.3 高光利润率机制

**概念**: 商品历史上达到过的最高利润率，代表该商品的利润潜力。

**当前实现**（简化版）:
```python
高光利润率 = (当前利润率 × 1.5).clip(lower=15, upper=50)
```

**应用场景**: 利润修复
```python
是否可修复 = (当前利润率 < 高光利润率) & (~是否亏损)
```

**TODO**: 从历史数据中计算真实的高光利润率
```python
# 未来实现
高光利润率 = 历史订单数据.groupby('商品名称')['利润率'].max()
```

### 8.4 弹性系数学习机制

**目标**: 从实际调价效果中学习，持续优化预测准确性。

**工作流程**:

1. **调价执行**: 商家根据建议调整价格
2. **效果观察**: 系统监测调价后7天的销量变化
3. **弹性学习**: 反推实际弹性系数
   ```python
   实际弹性 = (销量变化率) / (价格变化率)
   ```
4. **加权更新**: 
   ```python
   新弹性 = (旧弹性 × 旧样本数 + 新弹性) / (旧样本数 + 1)
   ```
5. **优先使用**: 下次调价时优先使用学习到的弹性系数

**数据有效性检查**:
- 价格变化幅度 ≥ 2%
- 调价前必须有销量
- 弹性合理性: -5 < 弹性 < 1
- 排除异常情况（如同时有促销活动）

**存储位置**: `components/today_must_do/learned_elasticity.json`


### 8.5 UI/UX优化

#### 场景按钮

替代原来的10个角色按钮，简化为4个场景按钮：

```python
场景按钮 = [
    ('pricing-role-loss', '🩸 亏损止血'),
    ('pricing-role-volume', '📈 利润修复'),
    ('pricing-role-slow', '📦 滞销清仓'),
    ('pricing-role-traffic', '🎯 促销引流'),
]
```

#### 表格列优化

根据场景动态调整展示列：

| 场景 | 特殊列 |
|------|--------|
| 亏损止血 | 真实保本价、亏损额 |
| 利润修复 | 高光利润率、差距 |
| 滞销清仓 | 滞销天数、库存 |
| 促销引流 | 日均销量 |

#### 弹性系数显示

```python
if '学习' in elasticity_source:
    elasticity_display = f"🎓{elasticity:.2f}"  # 学习数据
elif '历史' in elasticity_source:
    elasticity_display = f"📊{elasticity:.2f}"  # 历史数据
elif '默认' in elasticity_source or '品类' in elasticity_source:
    elasticity_display = f"⚠️{elasticity:.2f}"  # 品类默认
```

---

## 已知问题

### 9.1 高光利润率计算

**问题**: 当前使用简化算法（当前利润率 × 1.5），不够准确。

**影响**: 利润修复场景的商品筛选可能不够精准。

**解决方案**: 
```python
# 从历史订单数据中计算真实的高光利润率
def calculate_highlight_margin(df: pd.DataFrame) -> pd.DataFrame:
    """
    计算每个商品的历史最高利润率
    
    Args:
        df: 历史订单数据（至少3个月）
    
    Returns:
        商品名称 -> 高光利润率的映射
    """
    # 按商品+日期聚合
    daily_margin = df.groupby(['商品名称', '日期']).apply(
        lambda x: ((x['实收价格'].sum() - x['成本'].sum()) / x['实收价格'].sum() * 100)
    )
    
    # 取每个商品的最高利润率
    highlight_margin = daily_margin.groupby('商品名称').max()
    
    return highlight_margin
```

### 9.2 弹性系数学习的触发机制

**问题**: 当前弹性学习需要手动触发，没有自动化流程。

**影响**: 学习数据积累缓慢，预测准确性提升有限。

**解决方案**:
1. **定时任务**: 每天凌晨自动检测价格变化，计算弹性系数
2. **实时监控**: 在调价执行后7天自动触发学习
3. **批量学习**: 从历史调价记录中批量学习

```python
def auto_learn_elasticity_daily():
    """
    每日自动学习弹性系数
    
    流程:
    1. 检测7天前的价格变化
    2. 对比调价前后的销量
    3. 计算弹性系数并更新
    """
    # 获取7天前的数据
    today = datetime.now()
    change_date = today - timedelta(days=7)
    
    # 检测价格变化
    price_changes = detect_price_changes_from_orders(df, change_date)
    
    # 学习弹性系数
    for _, change in price_changes.iterrows():
        learn_elasticity_from_price_change(
            product_code=change['店内码'],
            channel=change['渠道'],
            old_price=change['旧价格'],
            new_price=change['新价格'],
            old_daily_sales=change['调价前日均销量'],
            new_daily_sales=change['调价后日均销量'],
            days_after_change=7
        )
```

### 9.3 滞销品库存数据准确性

**问题**: 部分商品可能没有库存字段，导致滞销判断不准确。

**影响**: 滞销清仓场景可能遗漏或误判商品。

**解决方案**:
1. **数据补全**: 从ERP系统同步库存数据
2. **降级策略**: 无库存字段时，使用销量趋势判断
   ```python
   # 无库存字段时的降级逻辑
   if not stock_col:
       # 前7天有销量 且 最近3天零销量
       滞销品 = (前7天销量 > 0) & (最近3天销量 == 0)
   ```

### 9.4 价格弹性的外部因素干扰

**问题**: 价格变化的同时可能有促销活动、竞品调价等外部因素，影响弹性计算准确性。

**影响**: 学习到的弹性系数可能不准确。

**解决方案**:
1. **活动标记**: 在调价记录中标记是否有促销活动
2. **异常值过滤**: 
   ```python
   # 过滤异常弹性
   if elasticity > 1.0:  # 涨价反而增销量
       return None  # 可能有促销活动干扰
   if elasticity < -5:  # 弹性过大
       return None  # 可能有其他因素
   ```
3. **多样本平滑**: 使用加权平均，降低单次异常的影响

### 9.5 数据周期动态计算的边界情况

**问题**: 数据天数不足时（如只有1-2天），日均销量计算不准确。

**影响**: 调价建议可能不合理。

**解决方案**:
```python
# 数据天数检查
if DATA_DAYS < 7:
    # 提示用户数据不足
    return dbc.Alert([
        html.I(className="bi bi-exclamation-triangle me-2"),
        f"数据天数不足（当前{DATA_DAYS}天），建议选择至少7天的数据。"
    ], color="warning")
```

---

## 优化建议

### 10.1 短期优化（1-2周）

#### 1. 完善高光利润率计算

**优先级**: 高

**实现方案**:
```python
def calculate_highlight_margin_from_history(df: pd.DataFrame) -> Dict[str, float]:
    """
    从历史数据计算高光利润率
    
    要求: 至少3个月的历史数据
    """
    # 按商品+周聚合（避免日波动）
    weekly_margin = df.groupby(['商品名称', pd.Grouper(key='日期', freq='W')]).apply(
        lambda x: ((x['实收价格'].sum() - x['成本'].sum()) / x['实收价格'].sum() * 100)
        if x['实收价格'].sum() > 0 else 0
    )
    
    # 取每个商品的90分位数（排除异常高值）
    highlight_margin = weekly_margin.groupby('商品名称').quantile(0.9)
    
    # 最低15%，最高50%
    highlight_margin = highlight_margin.clip(lower=15, upper=50)
    
    return highlight_margin.to_dict()
```

**集成方式**:
```python
# 在prepare_pricing_data_v2中
if '日期' in df.columns:
    highlight_dict = calculate_highlight_margin_from_history(df)
    product_data['高光利润率'] = product_data['商品名称'].map(highlight_dict).fillna(15)
else:
    # 降级到简化算法
    product_data['高光利润率'] = (product_data['利润率'] * 1.5).clip(lower=15, upper=50)
```

#### 2. 添加弹性学习自动化任务

**优先级**: 高

**实现方案**:
```python
# 在主看板启动时注册定时任务
from apscheduler.schedulers.background import BackgroundScheduler

scheduler = BackgroundScheduler()

def daily_elasticity_learning_task():
    """每日凌晨2点执行弹性学习"""
    try:
        df = get_real_global_data()
        if df is not None and not df.empty:
            # 检测7天前的价格变化
            today = datetime.now()
            change_date = today - timedelta(days=7)
            
            # 学习弹性系数
            learn_count = auto_learn_elasticity_from_history(df, change_date)
            print(f"[弹性学习] 成功学习 {learn_count} 个商品的弹性系数")
    except Exception as e:
        print(f"[弹性学习] 失败: {e}")

# 注册任务
scheduler.add_job(daily_elasticity_learning_task, 'cron', hour=2, minute=0)
scheduler.start()
```

#### 3. 优化滞销品识别逻辑

**优先级**: 中

**改进点**:
1. 支持自定义滞销天数阈值
2. 考虑商品生命周期（新品vs老品）
3. 季节性商品特殊处理

```python
def get_stagnant_products_v2(
    df: pd.DataFrame,
    store: str = None,
    level: str = 'all',
    custom_days: int = None,  # 自定义滞销天数
    exclude_new_products: bool = True,  # 排除新品（上架<30天）
    seasonal_adjust: bool = True  # 季节性调整
) -> pd.DataFrame:
    """
    增强版滞销品识别
    """
    # ... 原有逻辑 ...
    
    # 排除新品
    if exclude_new_products:
        product_first_sale = df.groupby('商品名称')['日期'].min()
        new_products = product_first_sale[
            (last_date - product_first_sale).dt.days < 30
        ].index
        result = result[~result['商品名称'].isin(new_products)]
    
    # 季节性调整（如冰品在冬季不算滞销）
    if seasonal_adjust:
        current_month = last_date.month
        seasonal_categories = {
            '冰品': [11, 12, 1, 2],  # 冬季
            '取暖': [5, 6, 7, 8],    # 夏季
        }
        for cat, months in seasonal_categories.items():
            if current_month in months:
                result = result[~result['一级分类'].str.contains(cat, na=False)]
    
    return result
```

### 10.2 中期优化（1-2月）

#### 1. 引入机器学习模型预测弹性

**优先级**: 中

**方案**: 使用XGBoost/LightGBM训练弹性预测模型

**特征工程**:
```python
features = [
    # 商品特征
    '一级分类', '二级分类', '品牌',
    '当前价格', '成本', '利润率',
    '商品原价', '折扣率',
    
    # 销售特征
    '日均销量', '销量排名', '销售额占比',
    '动销天数', '库存周转率',
    
    # 营销特征
    '营销占比', '是否促销', '促销类型',
    
    # 渠道特征
    '渠道', '门店', '区域',
    
    # 时间特征
    '星期', '月份', '是否节假日',
    
    # 竞品特征（如果有）
    '竞品价格', '竞品销量',
]

target = '弹性系数'
```

**模型训练**:
```python
from lightgbm import LGBMRegressor

def train_elasticity_model(training_data: pd.DataFrame):
    """
    训练弹性预测模型
    
    Args:
        training_data: 包含特征和目标的训练数据
    """
    X = training_data[features]
    y = training_data['弹性系数']
    
    # 分类特征编码
    categorical_features = ['一级分类', '二级分类', '品牌', '渠道', '门店']
    for col in categorical_features:
        X[col] = X[col].astype('category')
    
    # 训练模型
    model = LGBMRegressor(
        n_estimators=100,
        learning_rate=0.05,
        max_depth=6,
        random_state=42
    )
    model.fit(X, y, categorical_feature=categorical_features)
    
    return model

def predict_elasticity_ml(model, product_features: pd.DataFrame) -> float:
    """使用ML模型预测弹性系数"""
    return model.predict(product_features)[0]
```

**集成到弹性获取流程**:
```python
def get_product_elasticity_v2(
    product_code: str,
    channel: str,
    category: str,
    product_features: pd.DataFrame = None,
    ml_model = None
) -> Tuple[float, str]:
    """
    增强版弹性获取（支持ML预测）
    """
    # 1. 学习数据（最高优先级）
    learned = get_learned_elasticity(product_code, channel)
    if learned and learned[1] >= 3:  # 至少3个样本
        return (learned[0], f"学习数据（{learned[1]}次）")
    
    # 2. ML模型预测（新增）
    if ml_model and product_features is not None:
        try:
            elasticity = predict_elasticity_ml(ml_model, product_features)
            return (elasticity, "ML模型预测")
        except:
            pass
    
    # 3. 历史数据
    # ... 原有逻辑 ...
    
    # 4. 品类默认
    # ... 原有逻辑 ...
```

#### 2. 多目标优化调价方案

**优先级**: 中

**目标函数**:
```python
def multi_objective_pricing(
    products_df: pd.DataFrame,
    objectives: Dict[str, float]
) -> pd.DataFrame:
    """
    多目标优化调价方案
    
    Args:
        products_df: 商品数据
        objectives: 优化目标权重
            {
                'profit': 0.5,      # 利润最大化
                'revenue': 0.2,     # 销售额最大化
                'margin': 0.2,      # 利润率提升
                'risk': 0.1,        # 风险最小化
            }
    
    Returns:
        优化后的调价方案
    """
    from scipy.optimize import minimize
    
    def objective_function(prices):
        """综合目标函数"""
        # 预测新销量
        new_quantities = predict_quantities(prices, elasticities)
        
        # 计算各目标
        profit = np.sum((prices - costs) * new_quantities)
        revenue = np.sum(prices * new_quantities)
        margin = np.mean((prices - costs) / prices)
        risk = np.sum(np.abs(prices - current_prices) / current_prices)
        
        # 加权求和（利润和收入最大化，风险最小化）
        score = (
            objectives['profit'] * profit +
            objectives['revenue'] * revenue +
            objectives['margin'] * margin * 1000 -  # 放大margin的影响
            objectives['risk'] * risk * 100  # 惩罚大幅调价
        )
        
        return -score  # 最小化负值 = 最大化正值
    
    # 约束条件
    constraints = [
        # 保本价约束
        {'type': 'ineq', 'fun': lambda x: x - floor_prices},
        # 最高价约束
        {'type': 'ineq', 'fun': lambda x: ceiling_prices - x},
    ]
    
    # 优化求解
    result = minimize(
        objective_function,
        x0=current_prices,
        method='SLSQP',
        constraints=constraints
    )
    
    return result.x
```

#### 3. A/B测试框架

**优先级**: 低

**目标**: 验证调价效果，优化策略

**实现方案**:
```python
class PricingABTest:
    """调价A/B测试框架"""
    
    def __init__(self, test_name: str, test_duration_days: int = 14):
        self.test_name = test_name
        self.test_duration_days = test_duration_days
        self.test_groups = {}
    
    def create_test_groups(self, products: List[str], split_ratio: float = 0.5):
        """
        创建测试组和对照组
        
        Args:
            products: 商品列表
            split_ratio: 测试组比例
        """
        np.random.shuffle(products)
        split_idx = int(len(products) * split_ratio)
        
        self.test_groups = {
            'test': products[:split_idx],      # 测试组（执行调价）
            'control': products[split_idx:]    # 对照组（不调价）
        }
    
    def apply_pricing_strategy(self, strategy: str):
        """对测试组应用调价策略"""
        # 只对测试组商品执行调价
        test_products = self.test_groups['test']
        # ... 调价逻辑 ...
    
    def analyze_results(self, df: pd.DataFrame) -> Dict[str, Any]:
        """
        分析A/B测试结果
        
        Returns:
            {
                'test_group': {
                    'avg_profit_change': 利润变化%,
                    'avg_sales_change': 销量变化%,
                    'avg_margin_change': 利润率变化,
                },
                'control_group': {...},
                'statistical_significance': p_value,
                'conclusion': '测试组显著优于对照组' / '无显著差异'
            }
        """
        from scipy.stats import ttest_ind
        
        # 计算测试组和对照组的指标
        test_metrics = self._calculate_metrics(df, self.test_groups['test'])
        control_metrics = self._calculate_metrics(df, self.test_groups['control'])
        
        # 统计显著性检验
        t_stat, p_value = ttest_ind(
            test_metrics['profit_changes'],
            control_metrics['profit_changes']
        )
        
        return {
            'test_group': test_metrics,
            'control_group': control_metrics,
            'statistical_significance': p_value,
            'conclusion': '测试组显著优于对照组' if p_value < 0.05 else '无显著差异'
        }
```

### 10.3 长期优化（3-6月）

#### 1. 动态定价系统

**目标**: 根据实时数据自动调整价格

**核心功能**:
- 实时监控销量、库存、竞品价格
- 自动触发调价（无需人工干预）
- 智能止损机制（效果不佳自动回调）

#### 2. 竞品价格监控

**目标**: 考虑竞品价格因素，优化定价策略

**数据来源**:
- 爬虫抓取竞品价格
- 第三方数据服务
- 用户手动录入

**应用**:
```python
def adjust_price_with_competitor(
    our_price: float,
    competitor_price: float,
    strategy: str = 'follow'  # 'follow'/'lead'/'ignore'
) -> float:
    """
    考虑竞品价格的调价策略
    
    Args:
        our_price: 我们的价格
        competitor_price: 竞品价格
        strategy: 
            - 'follow': 跟随策略（略低于竞品）
            - 'lead': 领先策略（略高于竞品，强调品质）
            - 'ignore': 忽略竞品
    """
    if strategy == 'follow':
        return competitor_price * 0.95  # 低5%
    elif strategy == 'lead':
        return competitor_price * 1.05  # 高5%
    else:
        return our_price
```

#### 3. 个性化定价

**目标**: 根据用户画像、购买历史等因素，提供个性化价格

**实现难点**:
- 需要用户级数据
- 可能涉及价格歧视问题
- 技术复杂度高

---

## 附录

### A. 关键公式汇总

```python
# 1. 利润率
利润率 = (售价 - 成本) / 售价 × 100

# 2. 真实保本价
真实保本价 = 成本 / (1 - 平台费率)

# 3. 价格弹性系数
弹性系数 = 销量变化率 / 价格变化率

# 4. 销量预测
预测销量 = 当前销量 × (1 + 价格变化率 × 弹性系数)

# 5. 利润预测
预测利润 = (新价格 - 成本) × 预测销量

# 6. 目标价格
目标价格 = 成本 / (1 - 目标利润率)

# 7. 营销占比
营销占比 = 营销成本 / 销售额 × 100

# 8. 折扣率
折扣率 = 实售价 / 原价

# 9. 销量排名百分位
销量排名 = rank(销量, pct=True)

# 10. 日均销量
日均销量 = 总销量 / 数据天数
```

### B. 数据字段映射

| 业务字段 | 数据库字段（优先级） | 说明 |
|----------|---------------------|------|
| 商品标识 | 店内码 > 条码 > 商品名称 | 优先使用店内码 |
| 售价 | 商品实售价 > 实收价格 | 优先使用商品实售价 |
| 成本 | 商品采购成本 > 成本 | 需除以销量得到单品成本 |
| 销量 | 月售 > 销量 | - |
| 原价 | 商品原价 | - |
| 库存 | 剩余库存 > 库存 | - |
| 分类 | 一级分类名 > 一级分类 | - |
| 渠道 | 平台 > 渠道 | - |
| 日期 | 日期 > 下单时间 | - |

### C. 常见问题FAQ

**Q1: 为什么调价后销量没有按预测变化？**

A: 可能原因：
1. 弹性系数不准确（使用默认值）
2. 有外部因素干扰（促销活动、竞品调价）
3. 观察周期太短（建议至少7天）
4. 季节性因素影响

**Q2: 如何提高弹性系数的准确性？**

A: 
1. 积累更多调价样本，让系统学习
2. 定期更新品类默认弹性
3. 考虑引入ML模型预测
4. 排除异常调价记录（如促销期间）

**Q3: 滞销品降价后仍然卖不动怎么办？**

A:
1. 检查库存数据是否准确
2. 考虑商品是否已过期/过季
3. 尝试更大幅度降价（接近成本价清仓）
4. 配合营销活动（满减、买赠）
5. 考虑下架处理

**Q4: 亏损止血场景下，涨价后销量大幅下降怎么办？**

A:
1. 检查是否涨幅过大（建议分步调整）
2. 评估是否有替代品竞争
3. 考虑优化成本而非提价
4. 如果是引流款，可能需要接受亏损

**Q5: 如何批量执行调价方案？**

A:
1. 导出Excel调价清单
2. 在电商平台后台批量导入
3. 或使用API接口自动同步
4. 建议分批执行，观察效果

---

## 更新日志

### V3.0 (2025-12-10)
- ✨ 新增四大调价场景（亏损止血、利润修复、滞销清仓、促销引流）
- ✨ 引入真实保本价计算（不含营销费用）
- ✨ 新增高光利润率机制
- ✨ 新增弹性系数学习机制
- 🐛 修复单品成本计算错误
- 🐛 修复滞销品库存判断逻辑
- 💄 优化UI，简化场景按钮
- 📝 完善开发文档

### V2.0 (2025-11-28)
- ✨ 独立数据处理，不依赖诊断模块
- ✨ 新增10种商品角色识别
- ✨ 新增价格弹性分析
- ✨ 支持涨价/降价双向调整
- 🐛 修复保本价计算问题

### V1.0 (2025-10-15)
- 🎉 初始版本发布
- ✨ 基础调价功能
- ✨ 简单的利润率计算

---

## 参考资料

1. **价格弹性理论**: [Wikipedia - Price Elasticity of Demand](https://en.wikipedia.org/wiki/Price_elasticity_of_demand)
2. **动态定价**: [Dynamic Pricing Strategies](https://www.mckinsey.com/capabilities/growth-marketing-and-sales/our-insights/dynamic-pricing)
3. **零售定价策略**: [Retail Pricing Strategies](https://www.shopify.com/retail/pricing-strategies)
4. **机器学习定价**: [ML for Pricing Optimization](https://towardsdatascience.com/machine-learning-for-pricing-optimization-5e5e5e5e5e5e)

---

**文档维护**: 请在每次重大更新后同步更新本文档

**联系方式**: 如有问题或建议，请联系开发团队
